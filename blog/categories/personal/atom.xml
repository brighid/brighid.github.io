<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: personal | Strongly Emergent]]></title>
  <link href="http://stronglyemergent.com//blog/categories/personal/atom.xml" rel="self"/>
  <link href="http://stronglyemergent.com//"/>
  <updated>2015-11-28T03:31:05-08:00</updated>
  <id>http://stronglyemergent.com//</id>
  <author>
    <name><![CDATA[Strongly Emergent Systems]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Two Traps]]></title>
    <link href="http://stronglyemergent.com//blog/2013/two-traps/"/>
    <updated>2013-07-02T14:25:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/two-traps</id>
    <content type="html"><![CDATA[<p>Joel Spolsky famously opined that you should look for two things when hiring a programmer:
<a href="http://www.joelonsoftware.com/articles/GuerrillaInterviewing3.html">Smart, and Gets Things Done</a>. Now, there are a lot of smart people in the world (with a
nod in the direction of <a href="http://en.wikipedia.org/wiki/Cattell%E2%80%93Horn%E2%80%93Carroll_theory">the fox/hedgehog debate</a>), and plenty of them spend some time
programming. Even though there are also a great many people who think themselves smarter than they
are, there is a thriving body of lore on filtering that demographic out. So most of the task of
evaluating programmers is about evaluating how and if they Get Things Done.</p>

<p>Evaluating yourself this way is a good skill to have; lately I&rsquo;ve been trying to build more and
tinker more on account of being less-than-fully satisfied with what I see in my
self-evaluation. I&rsquo;ve also noticed two failure modes that smart programmers may fall into (one of
which I&rsquo;m doing my darndest to avoid), running parallel to the symbols-versus-understanding sides
of the <a href="http://en.wikipedia.org/wiki/Chinese_room">Chinese Room Argument</a>. The argument, oversimplified, is about whether or not
it&rsquo;s possible to infer that an unseen conversational partner who manipulates symbols correctly,
<em>understands</em> the communication.</p>

<p>A self-taught programmer is proficient in manipulating symbols, but is vulnerable to the failure
mode of not <em>understanding</em> them, of having a <a href="http://me.veekun.com/blog/2011/04/16/architectural-fallacies/#the-xy-problem">myopia about methods and goals</a>. On the
other hand, engineers who&rsquo;ve been involved in trying to hire from university computer science
departments can attest that CS shops produce a certain proportion of people who understand why all
of those symbol-manipulation rules are what they are, and who know a great deal about the rules and
how they are implemented, but who are curiously unable to actually perform the manipulation of
symbols and the latching-together of symbols into structures&mdash;no GitHub account, no projects of
their own, no open-source contributions.</p>

<p>I&rsquo;m nothing like the first person to notice these failure modes, but I think that identifying them
as such (<em>not</em> as &ldquo;all self-taught programmers are flaky&rdquo; or &ldquo;a CS degree is superfluous&rdquo;) is
helpful. Identifying a problem opens up the possibility of solving it. For me, it was humbling to
stumble on the Chinese Room Argument and realize that while I&rsquo;m good at manipulating the symbols,
that is not the same as fluency and I have a lot of work to do ahead of me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Challenged]]></title>
    <link href="http://stronglyemergent.com//blog/2013/challenged/"/>
    <updated>2013-03-07T15:17:00-08:00</updated>
    <id>http://stronglyemergent.com//blog/2013/challenged</id>
    <content type="html"><![CDATA[<p>I&rsquo;m hunting for a new job right now: that&rsquo;s always a tricky thing, and it&rsquo;s easy for it to make me nervous. I&rsquo;m in that bootstrapped/self-taught bind where my skillset and résumé look weird to the corporate world - I taught myself Python and then fell in love with Emacs Lisp, especially its overlap with Common Lisp; I&rsquo;m proficient with both of those and speak JavaScript at the high-school Spanish level. I&rsquo;m also reading up on Objective-C, have brushed up against Ruby a few times, grasp the basics of Perl, have put together a cohesive LaTeX document, think of Git as a basic requirement of a serious project, and can run basic SQL queries. <a href="https://github.com/brighid/">I have a GitHub profile</a> that I&rsquo;m gradually adding code to, and this blog where I&rsquo;m getting back into the habit of article-length writing. I am, in other words, an engineer entirely capable of finding their own ass with both hands.</p>

<p>&ldquo;That&rsquo;s nice,&rdquo; said my management-track pal. &ldquo;What do you want to <em>do</em>? Where do you want to work in particular &mdash; what kind of work do you want to do &mdash; what are you doing to do for them?&rdquo;</p>

<p>That takes some more thought. I&rsquo;m just far enough along to be conscious of the green-engineer fallacy of wanting to work with a language instead of wanting to work on a project, so I can&rsquo;t say something as facile as &ldquo;I want a Lisp job!&rdquo;; similarly, while I identify with Bay Area startup culture pretty strongly, &ldquo;I want to work at a startup!&rdquo; isn&rsquo;t going to cut it either. Those are <em>features</em> I want a job to have, not the job itself.</p>

<p>So in response to my friend&rsquo;s challenge, here are three specific jobs I&rsquo;d like to do.</p>

<ul>
<li><p>Work on the Unix toolchain for Apple: new releases of OS X <a href="http://apple.blogoverflow.com/2012/07/interesting-new-unix-commandsbinaries-in-os-x-mountain-lion/">show up with new terminal utilities</a>, and the intersection of Unix beard and Apple fan makes this a job I&rsquo;d love to do.</p></li>
<li><p>Work on the API team at Stripe or Square: these are two of my favorite startups, and I think that payments are a hugely important place to apply the lever of technology. Unevenly distributed information and bad liquidity are two longstanding problems: with a smartphone in everyone&rsquo;s pocket, radical improvements in our solutions to these problems are possible, and Square and Stripe are doing awesome work on that. I&rsquo;d want to work on the API team to make the services that Stripe and Square provide as language-agnostic as possible - the intersection of mission and language-diversity makes this a job I&rsquo;d love to do.</p></li>
<li><p>Work on open data and developer relations for CalTrain, Golden Gate Transit, MUNI, and the Bay&rsquo;s other transit agencies. &ldquo;Which transit vehicles are where, and where will they be next?&rdquo; is a question that people want answers to so badly that they more or less <em>inflicted</em> an API on MUNI. I&rsquo;m a cyclist and a public transit rider; I think that better mass-transit is good for everyone, and the interesting benefits that the transit agencies themselves could derive from good data, make this a job I&rsquo;d love to do.</p></li>
</ul>


<p>The nice thing about this exercise is that it reveals that there are a lot of interesting challenges in the world, even when you filter it down to &ldquo;software engineering jobs in the Bay Area.&rdquo; I&rsquo;m going to keep looking, but I&rsquo;m grateful to my friend for pushing me towards this exercise. Meantime, if you&rsquo;re reading this and you&rsquo;re willing to take a chance on a bootstrapped afficionado-of-weird-languages hacker who wants to help change the world, <a href="http://careers.stackoverflow.com/stronglyemergent">you should check out my résumé</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Program Or Paradigm?]]></title>
    <link href="http://stronglyemergent.com//blog/2013/program-or-paradigm/"/>
    <updated>2013-03-03T17:08:00-08:00</updated>
    <id>http://stronglyemergent.com//blog/2013/program-or-paradigm</id>
    <content type="html"><![CDATA[<p>I&rsquo;m an emacs girl: emacs is the environment that taught me to love Lisp, emacs is most of the way to becoming an extension of my desires, emacs is, in Neal Stephenson&rsquo;s memorable phrase, &ldquo;the thermonuclear text editor.&rdquo; Like everyone else who&rsquo;s smitten with it, I have a theory about What Makes Emacs Different: emacs is a paradigm, not a program.</p>

<p>Let&rsquo;s talk about interfaces. In 1976, using computers was harder &mdash; not because people were dumber or worse at design, but because there were fewer giants on whose shoulders to stand and because the computers themselves were incapable of working as hard. That meant, in turn, that the 1976 OS couldn&rsquo;t be as generous to user-space programs as the 2013 OS can be. In 2013, the OS can step up and be the primary answerer of the question, &ldquo;how do I use this computer?&rdquo; In 1976, the OS is too busy running the computer to do more than nod in the Bourne shell&rsquo;s direction. This has considerable downsides for programs: they have to do everything themselves. But they have one important freedom: they get to answer the user&rsquo;s fundamental &ldquo;how do I use this computer?&rdquo; question <em>any way they want.</em></p>

<p>In 2013, the OS has an answer to this question, more or less opinionated according to the OS. Because it is easier to let the OS answer the question, that&rsquo;s what most programs do: they use the OS&rsquo;s chrome, file management, and other facilities. There are many good things about this: there are many more useful programs in the world than when programs had to do everything themselves. But it is a tradeoff: a program that comes from the world where the OS provides easy answers is almost completely unable to provide its own answers.</p>

<p>This is where we come back to emacs: the reason that emacs can look so strange in 2013 is that it has its own opinions, strong ones, about how to relate to files, displays, and text. Emacs is a <em>paradigm for how to interact with text.</em> It has stronger opinions than modern programs because it comes from a time when programs had the ability to answer those questions themselves. A program from the strong-OS era - for example, Eclipse - or which adapted itself to strong OSes - for example, Microsoft Word - is restricted by being situated within the boundaries established the by the OS' answer to &ldquo;how do I use this computer?&rdquo; Eclipse and Word are <em>programs</em> that edit text. Emacs is a <em>language</em> for editing text.</p>

<p>One of the clearest ways to see this is to compare emacs to something that&rsquo;s more similar to it than Eclipse or Word: <code>vi</code>. With its movement-operation-modifier syntax for commands, vi has its own answer to the question &ldquo;how do I use this computer?&rdquo; that&rsquo;s every bit as thorny for us 2013 folks as emacs' answer &mdash; and that&rsquo;s <a href="http://stackoverflow.com/a/1220118/">just as powerful when you grok it deeply</a>. In the context of their 1976 roots, you can see that the creators of both vi and emacs embarked on the tremendously ambitious project of giving users a language in which to edit text. The existence and popularity of software that&rsquo;s pushing 40 years old and still being actively used and extended, is strong evidence that both did well (though we should check our <a href="http://en.wikipedia.org/wiki/Survivorship_bias">survivorship bias</a> and note that most programs from that era did not survive in the same way).</p>

<p>If you are someone who spends a lot of time with text, especially if you&rsquo;re a hacker, you should be using emacs or vi. There are many <a href="http://notepad-plus-plus.org/">okay</a> and <a href="http://www.sublimetext.com/">good</a> <a href="http://www.barebones.com/products/bbedit/">tools</a> for <a href="http://www.chocolatapp.com/">editing</a> <a href="http://macromates.com/">text</a> and <a href="http://panic.com/coda/">producing</a> <a href="http://www.jetbrains.com/idea/">code</a>, especially for <a href="https://developer.apple.com/xcode/">specific</a> <a href="http://www.microsoft.com/visualstudio/eng">domains</a>, but emacs and vi are the only <em>great</em> general-purpose editors. A program that wants to take advantage of the benefits that a modern OS offers could possibly be great - but it would have to be a <a href="http://www.lighttable.com/">different route</a> to greatness than emacs and vi took.</p>

<p>I spend a tremendous amount of time with prose and code, and emacs is a great match for me. For a large class of problems, my response to encountering them starts with <code>M-:</code>. I routinely try to use emacs' keyboard shortcuts in other contexts (e.g. switching tabs in Firefox with <code>C-x o</code>). I was actively excited when I found out that emacs had integrated a unit testing framework. When I tell you that you should use emacs, you should know that that&rsquo;s the kind of relationship I have with emacs. I think you should use emacs anyhow, because I think that when a task is important to you, you should use a great tool for it, not just the first good one you find. &ldquo;How will I use this computer to produce prose and code for the next 20 years?&rdquo; is a very, <em>very</em> important question to me.</p>

<p>The answer is emacs.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Past Is A Foreign Country]]></title>
    <link href="http://stronglyemergent.com//blog/2013/the-past-is-a-foreign-country/"/>
    <updated>2013-03-02T16:00:00-08:00</updated>
    <id>http://stronglyemergent.com//blog/2013/the-past-is-a-foreign-country</id>
    <content type="html"><![CDATA[<p>Communicating with your past self can be a little alarming. In the process of converting this blog
to OctoPress (because
<a href="http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/">PHP is a fractal of bad design</a>
and WordPress has its own problems on top of being a huge PHP legacy system), I learned not only
that <code>Liquid Exception: Unknown tag 'endif' in page</code> is Liquid&rsquo;s way of saying &ldquo;you forgot to
<em>start</em> that if-block, bro&rdquo;, I learned that my past self had very different priorities.</p>

<p>Not that this is <a href="news:">news:</a> as I&rsquo;ve gotten older, I&rsquo;ve gotten better at forgiving my past self for his
fuckups. It&rsquo;s still hard to forgive his eating habits, but bodies are complicated. I was surprised,
though, to learn that he was conflicted about whether to be a developer or a sysadmin. Seriously?
It&rsquo;s not a binary: pretty much the whole subfield of devops is people who&rsquo;re making interesting
choices about &ldquo;what if I pick things from both skillsets?&rdquo; While I now think of myself as an
engineer in general, not a sysadin or a developer, I am very happy that I am picking up bits and
pieces of CS theory and that I can still read Apache config files, whip up basic Perl one-liners,
and be on speaking terms with vim.</p>

<p>I admire the dedicated systems team at my work, but their job is not the job I want to do. I want
to <em>build things.</em> That&rsquo;s gotten more and more important to me over time &mdash; the thrill of
green-field development, of Something from Nothing, is one I want, over and over. Lucky me: I am
getting better and better at producing that experience for myself and making useful things along
the way.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Recommendation I Can't Get From LinkedIn]]></title>
    <link href="http://stronglyemergent.com//blog/2011/a-recommendation-i-cant-get-from-linkedin/"/>
    <updated>2011-05-11T14:27:28-07:00</updated>
    <id>http://stronglyemergent.com//blog/2011/a-recommendation-i-cant-get-from-linkedin</id>
    <content type="html"><![CDATA[<p>This one&rsquo;s short. I had several short-term co-workers lately, and one of them at the end of her tenure left me a nice note.</p>

<p><img src="/images/thankyou.jpg" alt="" /></p>

<p>That made me really happy. Helping people is a great feeling, and so is having your work acknowledged.  It&rsquo;s interesting, too, that the very things that make it easier to communicate, can also change the tone of communication.  There are interactions where a written, physical artifact used to be required, and is no longer required. I don&rsquo;t think this was ever one of them, really. So it&rsquo;s interesting that someone went out of their way to create this. I think that&rsquo;s perhaps a valuable way to look at the difference between digital and physical-artifact communications - you can send a different message, even with the same words. The range and shape of possible expression has changed.  If we had actually lost handwritten artifacts, I&rsquo;d be sad - but we haven&rsquo;t. They merely say something different now.</p>

<p>Take ownership of all of your communication, no matter what form you put it in.</p>
]]></content>
  </entry>
  
</feed>

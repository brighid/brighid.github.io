<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Strongly Emergent]]></title>
  <link href="http://stronglyemergent.com//blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://stronglyemergent.com//"/>
  <updated>2016-07-20T17:18:53-07:00</updated>
  <id>http://stronglyemergent.com//</id>
  <author>
    <name><![CDATA[Strongly Emergent Systems]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Two Traps]]></title>
    <link href="http://stronglyemergent.com//blog/2013/two-traps/"/>
    <updated>2013-07-02T14:25:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/two-traps</id>
    <content type="html"><![CDATA[<p>Joel Spolsky famously opined that you should look for two things when hiring a programmer: <a href="http://www.joelonsoftware.com/articles/GuerrillaInterviewing3.html">Smart, and Gets Things Done</a>.
Now, there are a lot of smart people in the world
(with a nod in the direction of <a href="http://en.wikipedia.org/wiki/Cattell%E2%80%93Horn%E2%80%93Carroll_theory">the fox/hedgehog debate</a>),
and plenty of them spend some time programming.
Even though there are also a great many people who think themselves smarter than they are, there is a thriving body of lore on filtering that demographic out.
So most of the task of evaluating programmers is about evaluating how and if they Get Things Done.</p>

<p>Evaluating yourself this way is a good skill to have;
lately I&rsquo;ve been trying to build more and tinker more on account of being less-than-fully satisfied with what I see in my self-evaluation.
I&rsquo;ve also noticed two failure modes that smart programmers may fall into
(one of which I&rsquo;m doing my darndest to avoid),
running parallel to the symbols-versus-understanding sides of the <a href="http://en.wikipedia.org/wiki/Chinese_room">Chinese Room Argument</a>.
The argument, oversimplified, is about whether or not it&rsquo;s possible to infer that an unseen conversational partner who manipulates symbols correctly,
<em>understands</em> the communication.</p>

<p>A self-taught programmer is proficient in manipulating symbols, but is vulnerable to the failure mode of not <em>understanding</em> them,
of having a <a href="http://me.veekun.com/blog/2011/04/16/architectural-fallacies/#the-xy-problem">myopia about methods and goals</a>.
On the other hand, engineers who&rsquo;ve been involved in trying to hire from university computer science departments
can attest that CS shops produce a certain proportion of people who understand why all of those symbol-manipulation rules are what they are,
and who know a great deal about the rules and how they are implemented,
but who are curiously unable to actually perform the manipulation of symbols and the latching-together of symbols into structures&mdash;
no GitHub account, no projects of their own, no open-source contributions.</p>

<p>I&rsquo;m nothing like the first person to notice these failure modes, but I think that identifying them as such
(<em>not</em> as &ldquo;all self-taught programmers are flaky&rdquo; or &ldquo;a CS degree is superfluous&rdquo;) is helpful.
Identifying a problem opens up the possibility of solving it.
For me, it was humbling to stumble on the Chinese Room Argument and realize that while I&rsquo;m good at manipulating the symbols,
that is not the same as fluency and I have a lot of work to do ahead of me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Negative 100 Points]]></title>
    <link href="http://stronglyemergent.com//blog/2013/negative-100-points/"/>
    <updated>2013-06-28T20:07:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/negative-100-points</id>
    <content type="html"><![CDATA[<p>A <a href="http://blogs.msdn.com/b/ericgu/archive/2004/01/12/57985.aspx">short post by Eric Gunnerson</a> about designing C#, nearly a decade old now, has stuck with me for a long time.</p>

<blockquote><p>[the question] implies that we started with an existing language (C++ and Java are the popular choices here),
and then started removing features until we got to a point where we liked.
That&rsquo;s not how the language got designed.
One of the big reasons we didn&rsquo;t do this is that it&rsquo;s really hard to remove complexity when you take a subtractive approach,
as removing a feature in one area may not allow you to revisit low-level design decisions,
nor will it allow you to remove complexity elsewhere, in places where it support the now-removed feature.
We decided on the additive approach instead, and worked hard to keep the complexity down.
One way to do that is through the concept of &ldquo;minus 100 points.&rdquo;
Every feature starts out in the hole by 100 points,
which means that it has to have a significant net positive effect on the overall package for it to make it into the language.
Some features are okay features for a language to have, they just aren&rsquo;t quite good enough to make it into the language.</p></blockquote>

<p>If this sounds familiar, it should:
this is another lens on the design philosophy, popularized in the developer community by Apple, that good design requires saying &ldquo;no.&rdquo;
Saying &ldquo;no&rdquo; a <em>lot.</em>
I applaud Apple for applying this philosophy so rigorously&mdash;
but it&rsquo;s important to remember that they&rsquo;re <a href="http://technet.microsoft.com/en-us/magazine/dn167709.aspx">not the only people who use it</a>, and their way is not the only way.
What you say &ldquo;no&rdquo; to, defines you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Prisoner Of Zend.php]]></title>
    <link href="http://stronglyemergent.com//blog/2013/the-prisoner-of-zend-dot-php/"/>
    <updated>2013-06-18T23:30:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/the-prisoner-of-zend-dot-php</id>
    <content type="html"><![CDATA[<p>It is surely not news to you that PHP is awful: there is a thriving sub-genre of tech blog posts about how very, very bad PHP is.
It should tell you something about what a horrid clown rodeo PHP is that even in the presence of Eevee&rsquo;s magisterial &ldquo;<a href="http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/">PHP: A Fractal Of Bad Design</a>&rdquo; article, so many of us feel compelled to contribute to the vast body of PHP-criticizing literature anyhow.
For my part, even after acknowledging excellent works (written by pals smarter than me) like <em>Fractal Of Bad Design</em>, man-of-mystery Pi&rsquo;s &ldquo;<a href="http://two-pi-r.livejournal.com/622760.html?format=light">PHP is a low-level programming language at the wrong level</a>,&rdquo; and Watts Martin&rsquo;s trenchant &ldquo;<a href="http://tracks.ranea.org/post/13908062333/php-is-not-an-acceptable-cobol">PHP is not an acceptable COBOL</a>,&rdquo; I still think there&rsquo;s more that needs saying.
There are plenty of languages that one may dislike, and there are plenty of warts on any language one does like — and yet, PHP is <em>sui generis</em> in its terribleness.</p>

<p>Before starting in on my own complaints, I&rsquo;m going to cite a rant from outside the programming world.
During Leonard Pierce&rsquo;s <a href="http://ludickid.livejournal.com/914741.html?format=light">massively acerbic chronicle of hating Billy Joel</a> there is an aside that I&rsquo;m gonna use to answer the question
&ldquo;why do people hate PHP in a way that people almost never hate JavaScript, C++, or Visual Basic, deeply flawed languages all?&rdquo;</p>

<blockquote><p>Just as one can argue that there were better World Series teams than the 1927 New York Yankees,
one can argue that various performers have written worse songs than those produced from the depressingly fertile mind of Billy Joel.
[&hellip;]
But while there are those who can honestly contend that the &lsquo;27 Bronx Bombers were not the greatest of all World Series teams, no one —
not even those who hate the Yankees with a soul-scorching fire, as do all right-thinking humans —
can argue that they are not the best baseball franchise ever.
The numbers simply speak for themselves.
No other team has even remotely come close to topping their total number of world championships.
Similarly, no other performer or group has ever had so many horrible songs become so successful on the charts as has Billy Joel.
<strong>Others have been worse; others have been bigger.
But no one has been bigger and badder at the same time than Billy Joel.</strong></p></blockquote>

<p>No one has been bigger and badder at the same time than PHP.
That&rsquo;s why.</p>

<p>To expand lightly on the criteria <em>Fractal</em> uses, <strong>a programming language is a tool for thinking about a problem space and for expressing solutions to particular problems in that space.</strong>
The writeups that I&rsquo;ve cited do great work on talking about this, but I think there&rsquo;s a little more that needs to be said.
We usually take this for granted, but a tool for task X should, as the very least, most basic requirement, help you accomplish X more often than it hinders you in trying to accomplish X.
PHP fails at this.
Additionally, software engineering does not happen in a vacuum.
Choices we engineers make affect others, including our future selves.
Software inherently has a social context, and how it interacts with that context, matters (this is where I think <a href="http://www.codinghorror.com/blog/2008/05/php-sucks-but-it-doesnt-matter.html">Jeff Atwood deeply misjudged PHP</a>).
So here&rsquo;s what I want to add to the conversation:</p>

<ul>
<li>PHP is not just a sub-optimal or distasteful tool, it&rsquo;s a <strong>treacherous</strong> one</li>
<li>In addition to being treacherous for those writing it, PHP <strong>pollutes the commons</strong></li>
<li>Because PHP is a treacherous tool whose use pollutes the commons, it <strong>should be torn out and demolished</strong> like an unsafe bridge or building</li>
</ul>


<h3>A Tool That Fits No Hand</h3>

<!-- A treacherous tool -->


<p>Part of why &ldquo;Fractal Of Bad Design&rdquo; commands attention is the sheer volume of issues with PHP it collects and contextualizes.
The gotchas, pitfalls, and boilerplate-chunks in PHP combine to produce an environment where simple, easy-to-read code is often <em>wrong</em>.
In turn, this means that code written with diligence and caution in PHP, is harder to give a close reading to.
You don&rsquo;t need to intensely scrutinize code every time you read it, but when you pick up your own code that you haven&rsquo;t worked with for a while, when you&rsquo;re reviewing code in a security-focused state of mind, or when you&rsquo;re deciding whether external changes require altering the code in front of you, giving the code a close reading is extremely important.
But when the simple way is often wrong, a close reading is far harder than it should be.
You will ask yourself many questions, individually small and not particularly difficult, but enormous in number and potential consequences.</p>

<ul>
<li>Which specific major, minor, and patch version of PHP was this file written against?</li>
<li>Does this function require a particular <code>ini_set()</code> invocation that could be clobbered elsewhere?</li>
<li>Does this if-block behave correctly when the result of an expression is <code>0</code> instead of <code>FALSE</code>?</li>
<li>Does all the code use <code>===</code> instead of <code>==</code>?</li>
<li>Does this function behave acceptably if one of its variables gets clobbered by a global?</li>
<li>Does this block handle <code>sleep()</code>&rsquo;s <a href="http://php.net/manual/en/function.sleep.php#refsect1-function.sleep-returnvalues">many possible return values</a> correctly?</li>
<li>Does this library <a href="http://software-gunslinger.tumblr.com/post/47131406821/php-is-meant-to-die">perpetrate asynchronous atrocities</a> behind my back?</li>
</ul>


<p>The burden of dealing with these questions means that PHP does not just make it possible write bad code, but that its quirks actively make it <em>harder to write good code</em> and more likely that you will write bad code.
You <em>can</em> write good code in PHP, but the path is a fearful one.
Compared to other languages, you will write more lines code to do the same tasks, it&rsquo;s harder to know or prove that the code you&rsquo;ve written is good, and the language ecosystem is so burdened with dubious code that good code cannot be quickly brought into projects of any significant age.
One of Perl&rsquo;s design goals is to &ldquo;make easy things easy and hard things possible.&rdquo;
PHP, as though coming from a mirror universe with a sinister goatee,
<a href="http://phpsadness.com/sad/52">makes easy things hard</a> and <a href="http://software-gunslinger.tumblr.com/post/48215406921/php-is-meant-to-die-continued">hard things impossible</a>
In a total inversion of good language design, a concise and readable piece of PHP is more likely to have bugs, not less.
This is what pushes PHP from &ldquo;a tool that I have distaste for&rdquo; to &ldquo;a tool that is <strong>bad</strong>&rdquo; — when I say that it is &ldquo;treacherous,&rdquo; I&rsquo;m talking about this property where simple code is prone not just to being wrong, but to being wrong in a way that tends to <a href="https://phpmanualmasterpieces.tumblr.com/post/66426423275/">fail silently</a> and to fail with <a href="https://bugs.php.net/bug.php?id=55439">extremely dangerous effects</a>.</p>

<p>We have a specific term for &ldquo;past technical decisions are making it harder to make the right technical decisions in the present&rdquo;: <a href="http://c2.com/cgi/wiki?TechnicalDebt">technical debt</a>.
Languages change over time.
Production environments often achieve stability specifically by slowing down their update cycle.
This much is normal.
However, the volume of PHP&rsquo;s technical debt makes updates much more of a problem for PHP than in the general case.
Because something like Python&rsquo;s <code>virtualenv</code> or Ruby&rsquo;s <code>rbenv</code> <a href="http://stackoverflow.com/questions/7182176/does-php-have-an-equivalent-to-pythons-virtualenv-or-rubys-sandbox">doesn&rsquo;t exist in the PHP world as of 2013</a>, incremental updates (either of PHP itself or of any library or C module you may happen to be using) are very difficult: the difficulty of using new versions of PHP is dominated by the most out-of-date libraries or language features a project uses.
Because of how hard it is to make them incremental, updates are risky: it is extremely difficult to fully understand and accurately predict their effects, especially in judging security and stability issues.
One of the ways that PHP fails as a tool is that when improvements in the language or in libraries come along, it makes it hard to take advantage of those improvements.</p>

<p>When the question of PHP&rsquo;s quality comes up, inevitably someone tries to use Wikipedia, Facebook, and WordPress as examples of PHP&rsquo;s success.
Even if you leave aside how that&rsquo;s like saying that most American universities are Harvard, it ignores that Wikipedia, Facebook, and WordPress all have significant problems that are directly attributable to their decision to use PHP!
If you are not prepared to deal with those problems, then you had better not use PHP.
To argue that PHP is a good tool because these large, successful projects have been built with PHP while ignoring that all of these projects had to make extraordinary investments in technical infrastructure, is to advocate that other people waste tremendous quantities of time and money.
More precisely, the fact that Wikipedia, Facebook, and WordPress all used PHP is <em>insufficient</em> to demonstrate that you personally should use PHP for anything: you must know how those projects work and what tradeoffs they made in order to to know whether their use of PHP means it&rsquo;s a good idea to use PHP for your application.</p>

<!-- Spoilers: It's not. -->


<p>Wikipedia is the easiest example to pick on here, because they provide all the evidence themselves.
Go and check out a copy of the MediaWiki source code (I&rsquo;m going to treat &ldquo;Wikipedia&rdquo; and &ldquo;MediaWiki&rdquo; as synonymous) and take a look at it.
Reflect on how many engineer-hours it took to get the project to that state, and how many more hours are being requested.
Reflect on the contents of their [&ldquo;Annoying Large Bugs&rdquo;][annoyinglarge] and [&ldquo;Annoying Little Bugs&rdquo;][annoyinglittle] pages.
If you want to use Wikipedia as a role model, being blind to Wikipedia&rsquo;s flaws is a terrible idea.</p>

<p>Because Wikipedia is such a high-profile target (huge PageRank points, huge repository of user-generated content, huge mindshare) there&rsquo;s a <a href="http://www.cvedetails.com/vendor/2360/Mediawiki.html">steady record of vulnerabilities</a> with MediaWiki.
If you get into the plumbing of Wikipedia, get under the layer that just presents pages to visitors, get familiar with the greasy-handed wiki-gnomes, you&rsquo;ll find all kinds of interesting infrastructure designed to cope with this.
As a social project, Wikipedia is not a bad project: it&rsquo;s an amazingly good one.
It&rsquo;s a triumph of the cooperative open-source ethos and an incalculably valuable community resource.
But as an engineering project, you should be very careful about emulating it.
You should make sure that you can invest proportionate engineer-hours into security and maintenance — and that you account for how a PHP-based project needs far more of those hours than other kinds of project.</p>

<p>Speaking of gigantic quantities of engineer-hours, there&rsquo;s Facebook.
Facebook is an even worse choice as an example of PHP&rsquo;s success, because Facebook has effectively re-built PHP from the ground up.
Look at their <a href="https://github.com/facebook/hiphop-php">HipHop PHP</a> project: it&rsquo;s replacing the default PHP interpreter wholesale and replacing Apache&rsquo;s <code>mod_php</code> as well.
You shouldn&rsquo;t use Facebook as evidence that your project should use PHP, because the way you use PHP is not like the way that Facebook uses PHP.
Facebook ended up writing not just their own PHP toolchain, but their own entire PHP runtime.
This is probably not the way you want to go for your project: it&rsquo;s expensive and optimizes for solving problems that you don&rsquo;t have.</p>

<p>On top of that, there are ways in which Facebook&rsquo;s usage of PHP is dubious, or at least suggests that they would rather not be using PHP.
Before the current version of HipHop, which is a VM that executes PHP, they were cross-compiling to C++.
When &ldquo;cross-compile to C++&rdquo; makes your project <em>less</em> painful, that&rsquo;s a bad sign.
This emphasizes the earlier point about technical debt: Facebook at this point is trapped in PHP and making the best of it.
They&rsquo;re up to the point where they&rsquo;re custom-compiling PHP and doing static-analysis optimization on it — which is to say, they are doing <a href="http://www.research.ibm.com/trl/people/mich/pub/200901_popl2009phpsem.pdf">original compsci research</a>, because PHP&rsquo;s internals are that much of a mess.</p>

<p>Nor is WordPress a good PHP role model.
It&rsquo;s gotten better over time, but the direction of its evolution is away from &ldquo;blog&rdquo; and towards &ldquo;maximalist content management system,&rdquo; which massively expands the number of things that can possibly go wrong.
WordPress has a huge difference from Wikipedia and Facebook: rather than being a giant application hosted and administered by someone else, WordPress is a PHP application that you can download, install, and investigate for yourself.
They&rsquo;ve invested a lot of effort in making that part easy.
Unfortunately, &ldquo;easy PHP&rdquo; is pretty much always &ldquo;insecure PHP.&rdquo;
So WordPress has a <a href="http://osvdb.org/search?search[vuln_title]=wordpress&amp;search[text_type]=alltext">long track record of nasty vulnerabilities</a>.
It also has a well-earned reputation as a tool spammers love.
Because it&rsquo;s a platform that you can set up yourself with no gatekeeper (compare to Movable Type, professionally hosted WordPress installations, or Blogger instances), it&rsquo;s become the best choice for spammers (who want to programmatically deploy large numbers of WordPress instances).
Then there&rsquo;s the architecture matter: maybe this is just taste, but I find things like <code>rewind_posts()</code> inherently suspect (and there are <a href="http://www.reddit.com/r/lolphp/comments/1etq3n/wordpress_will_automatically_convert_foo_to_foo/">unproven allegations</a> of grotesque features lurking in the codebase).
More substantially, there&rsquo;s mutable global state lurking all over the place (on top of the distressing action-at-a-distance issues PHP inherently has — see Eevee&rsquo;s writeup for more about that), the app buys into <a href="http://www.reddit.com/r/lolphp/comments/1dzvjk/wordpress_core_is_secure_stop_telling_people/c9vlcpi">the &ldquo;sanitize input&rdquo; voodoo</a>, and like most PHP apps, it requires a bunch of read-and-write access to its environment that other language ecosystems .
Wordpress' engineering problems lead to persistent and near-intractable security problems, and those problems affect more than just the people running WordPress blogs.</p>

<h3>The Superfund Site Of Programming Languages</h3>

<!-- Polluting the commons -->


<p>Because of the friction discussed earlier, problems fixed or mitigated in new versions of PHP (tremendous improvements on versions like PHP4) have a very long half-life before they&rsquo;re no longer found in the wild.
Obstacles to upgrading software don&rsquo;t have to be insurmountable to keep users on old versions, they just have to exist.
There&rsquo;s a big difference between &ldquo;easy enough that people <em>can</em> do it&rdquo; and &ldquo;easy enough that people <em>actually</em> do it,&rdquo; and PHP is on the wrong side of that difference.
The design &amp; usability world has known for a long time that if the right thing and the easy thing are different, your users will almost never do the right thing.
PHP&rsquo;s legacy of technical debt means that maintaining PHP code has far too much friction for maintainers to always do the right thing.
I throw the epithet &ldquo;avatar of technical debt&rdquo; at PHP sometimes, because this dynamic means that to use PHP at all is to incur a wallop of technical debt.
Worse, this technical debt is almost always an <a href="http://en.wikipedia.org/wiki/Externality#Negative">externality</a>, a cost that the person writing the code doesn&rsquo;t have to pay.
Instead, <a href="https://phpmanualmasterpieces.tumblr.com/post/78455397098/nothing-is-deprecated-everything-is-permitted">the cost is borne by unknown future engineers and users</a>.
Beware of externalities!
If you are not paying the real, full costs of your decisions, <a href="http://en.wikipedia.org/wiki/Moral_hazard">you will be led to make worse decisions</a>.
Because PHP fails so hugely at making the right thing easy, it tends to make the wrong thing the default — and the costs of dealing with the wrong thing are all too often externalized, whether that&rsquo;s from today&rsquo;s coder to the same person tomorrow, from an engineer to a sysadmin, or from the vendor to the users of a piece of software.</p>

<p>That it&rsquo;s hard to update PHP projects wouldn&rsquo;t matter if those projects were only relevant to their creators and users.
This is not the case: those projects are relevant to the public good.
As programmers, do not create, modify, or use software in isolation.
We interact with software in a social context, in a technological context, and in a networked context.
Similar to how herd immunity in medicine means that the chance of catching a particular disease is unevenly distributed, software vulnerabilities are dangerous even to people who aren&rsquo;t running the affected software.
The most common thing that an attacker might do with a compromised machine is suborn its resources, using it to propagate further attacks (e.g. having it join a botnet).
This is why it matters that PHP is so big and so bad: even if I don&rsquo;t write any PHP code and don&rsquo;t operate anything based on PHP (or on MySQL, its <a href="http://grimoire.ca/mysql/choose-something-else">co-conspirator in suckitude</a>), PHP is still a severe and frequent problem for me!</p>

<p>In the recent past:</p>

<ul>
<li>A security researcher finds that of sites vulnerable to password dumps, <a href="http://blog.passwordresearch.com/2013/02/passwords-found-in-wild-for-january-2013.html">most are built on PHP</a>.</li>
<li>A remote-code-execution vulnerability in two of the most popular WordPress plugins is discovered — and the subsequent patches have an <a href="http://hackertarget.com/running-wordpress-patch-your-plugins/">utterly dismal uptake rate</a>.</li>
<li>There are a multitude of PHP-based server control panels that have deeply <a href="http://seclists.org/fulldisclosure/2013/Apr/139">disturbing security problems</a> of <a href="http://www.reddit.com/r/programming/comments/1gfve8/how_not_to_handle_a_critical_security/">grave severity</a>.</li>
<li>A search on GitHub reveals a multitude of PHP projects open to a <a href="https://github.com/search?p=1&amp;q=extension%3Aphp+mysql_query+%24_GET&amp;ref=searchresults&amp;type=Code">trivial SQL injection</a> attack.</li>
<li>A bug in parsing URLs — surely an action that should be a core competency for a &ldquo;web language&rdquo;! — turns out to be <a href="https://www.idontplaydarts.com/2013/06/http-parameter-pollution-with-cookies-in-php/">implemented in the shoddiest way</a>.</li>
</ul>


<p>Returning to WordPress in particular, WordPress' popularity exacerbates these security problems: WordPress has become a platform as much as it is an app.
Going from app to platform is both difficult in general and difficult particularly in the security context.
A WordPress setup&rsquo;s susceptibility to attack comes not just from problems in code its users write nor just from problems in code that WordPress' creators write, but by those potential problems multiplied by <a href="http://thedailywtf.com/Articles/Pot-o-Gold.aspx">the worst code</a> in any plugin or theme being used.
There are a huge number of WordPress themes and plugins, and they can do anything they like.
For example, there&rsquo;s <a href="http://wordpress.org/plugins/repress/">RePress</a>, which staples a web proxy onto the side of your blog for the use of folks in locales where services like Google and Wikipedia are blocked.
Whatever one thinks of RePress, it&rsquo;s only possible for it to exist because WordPress just picks up plugin code and lets it do whatever it asks.
WordPress is a particularly acute example because its target audience is non-engineering users.
Someone who sets up an instance of MediaWiki, Joomla, or Drupal faces a higher barrier to entry than a WordPress user, who is the beneficiary of vigorous and successful efforts to make WordPress accessible to a wide audience.
Unfortunately, that experience of easy-to-install software ends up re-enacting the Windows 9x era: it&rsquo;s very easy to install things that create opportunities for attackers, and almost impossible to tell ahead of time which things are safe to install.
In WordPress' case, some of its most high-profile plugins, like the <a href="http://www.hyphenet.com/blog/2013/02/01/hackers-still-scanning-for-vulnerable-timthumb-scripts/">TimThumb image resizer</a> and the popular caching plugins, have seen remote-code-execution vulnerabilities that can be exploited at scale, by botnets — and which are particularly likely to succeed against users of WordPress whose blogs and their upkeep are not an every-waking-moment concern.</p>

<p>I worked with <a href="http://seclists.org/fulldisclosure/2009/Feb/255">Magento</a> professionally for a while, and one thing that gave me massive creepy-crawlies about it was that it has the same kind of wild and problematic plugin ecosystem as WordPress, but centered around an app that&rsquo;s meant to be handling people&rsquo;s credit-card information.
&ldquo;All the security of WordPress, also people use it to handle money!&rdquo; does not inspire confidence (though with eBay now running the show, there&rsquo;s a good chance that Magento will have the budget to shape up security-wise).</p>

<p>If the problems I&rsquo;ve been talking about only affected the people actually running that software, I&rsquo;d care far less.
It&rsquo;s important for people have to the right to make their own dang mistakes.
But these things don&rsquo;t happen in a vacuum.
Facebook is the ultimate example: <a href="http://insecure.org/search.html?q=facebook">a steady trickle of facebook vulnerabilities</a> make their way to light over time, and there are over a billion Facebook users who can be very directly affected by them.
Every unpatched MediaWiki install sitting around, every forgotten WordPress instance, every homebrew app quietly chugging away, is susceptible to becoming part of a botnet and worsening the state of the entire Internet.
Every machine that gets rooted, is another machine conducting attacks of one kind or another — and even all of <em>my</em> own servers run on an imaginary free-ponies-with-awesome-sparkles-and-no-security-vulnerabilities-ever language, a legion of zombie PHP-running boxes can still just throw denial-of-service attacks my way until it doesn&rsquo;t matter what I&rsquo;m running.</p>

<p>This is why it <em>matters</em> that PHP is both big and bad: by being both ubiquitous and insecure, it pollutes the commons.
It adds unncessary cost and friction to any project we undertake that&rsquo;s connected to the Internet — which is to say, to everything.
Every server that connects to the Internet has its attack surface artificially enlarged because PHP&rsquo;s own attack surface is so vast.
Programming doesn&rsquo;t happen in a vacuum, it happens in an ecosystem — an ecosystem that PHP-based systems have a long and terrifying track record of dumping nuclear waste into.</p>

<h3>Public Hazard</h3>

<!-- PHP is a public hazard -->


<p>Its being sub-optimal, distateful to me, or outright poorly designed, wouldn&rsquo;t <em>remotely</em> justify my spending time and heartache on telling people not to use PHP.
Likewise, I don&rsquo;t think that PHP will make you a worse programmer except in the extremely boring sense that it&rsquo;ll waste a lot of your time and thus make it harder to rack up the quantities of deliberate-focused-practice time that one needs for mastery, which is absolutely not a sense worth picking a fight over: everyone has a right to their own yak-shaving.
There are plenty of people out there being total jackasses &ldquo;in defense of&rdquo; PHP, but those people are freely deciding to be jackasses: their social deficiencies are very much separate from their choice of programming language (plus, Ruby is an amazing language and its community has no shortage of tremendous jackasses).
As a programmer who cares about craft and tools, I think other languages will reward your time &amp; effort far better than PHP, but if you don&rsquo;t use those, oh well.
I have zero interest in picking a fight over PHP on that basis.
As someone who cares about the Internet being safe and functional enough for me to buy music, check my credit card balance, and communicate with my friends, I want you to stop using PHP and replace existing PHP code — like, <strong>yesterday</strong> — and I think you should be restrained from using PHP for new projects.
I&rsquo;m willing to pick a fight about PHP on the basis of of its decade-and-counting track record of design problems that cause security problems that cause &ldquo;you don&rsquo;t write or use PHP but this is going to mess up your day anyhow!&rdquo; problems.</p>

<p>Software can&rsquo;t be isolated from its social context any more than it can be isolated from its technological context.
The social and technological context of modern software is the Internet.
With a large enough userbase, any software project is <em>de facto</em> infrastructure (especially if it participates in the Internet).
As builders of infrastructure, we have a moral responsibility to not build hazardous, shoddy infrastructure because doing so hurts everyone who uses or depends on that infrastructure, even indirectly.
PHP&rsquo;s track record demonstrates that it is a grossly deficient tool for building infrastructure.
When you undertake to build or maintain infrastructure, you take on a responsibility to everyone affected by the quality &amp; functionality of that infrastructure.
Choosing to use grossly deficient tools like PHP is irresponsible and unethical for builders of infrastructure, especially if it&rsquo;s justified in terms of ease or of being able to build a thing swiftly.
By definition, infrastructure projects require that you prioritize durability and certainty over ease and swiftness!
Nor is there an argument to be had on a &ldquo;the other tools are also flawed&rdquo; basis: none of the other tools have PHP&rsquo;s decade-long track record of massive deficiency, nor do their maintainers have the indifference towards fixing deficiencies that PHP&rsquo;s maintainers display.
It is only by combining its track record of problems with the long reach that those problems have, that PHP crosses the threshold of &ldquo;should people be restrained from using this tool?&rdquo;
No-one should lower the requirements for that kind of thing: we should be very, very wary of doing so.
PHP has met those requirements: there are no other tools in such wide use whose problems are so many, are inflicted on so many people beyond the tool&rsquo;s users, have gone unfixed for so long, have so few virtues to excuse them, and are the responsibility of maintainers who have done so little to fix them.
Nothing short of that should prompt the programming community to say &ldquo;no, this tool is not okay to use, stop.&rdquo;</p>

<p>How to attain the elimination of PHP is a question I don&rsquo;t have a good answer for, and it&rsquo;s obvious that the programming community as a whole hasn&rsquo;t yet come up with a good answer.
It&rsquo;s especially important to demand that a scheme for reducing &amp; eliminating PHP not make it more difficult to get into programming.
PHP offers &ldquo;you can just write code and see it work!&rdquo; and that&rsquo;s a hugely, hugely important feature for making programming accessible — the problem is that PHP offers this feature at a ruinously high cost and smudges the ink on the metaphorical price tag.
I also think it&rsquo;s going to be very difficult in general: I&rsquo;ve been comparing PHP to pollution-causing industrial tactics here, but America has not done at all a good job of holding people who cause pollution responsible for its harmful effects.</p>

<p>I look forward to a future where we&rsquo;ve invested the collective effort in building tools that fit our hands gracefully and that don&rsquo;t sabotage our efforts to build durable, predictable, world-improving infrastructure.
Software has both a social and a technological context: this means that the apparently-social problem of eliminating PHP also is a technical problem.
The technical problem is &ldquo;how do we build something better than PHP?&rdquo; and the tremendous numbers of beautiful &amp; useful solutions we&rsquo;ve already come up with for that problem, give me every confidence that we can handle that part.
Now let&rsquo;s work on the social part.</p>

<p><em>Note: this post was updated in summer 2016.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Date With Ruby]]></title>
    <link href="http://stronglyemergent.com//blog/2013/first-date-with-ruby/"/>
    <updated>2013-06-15T08:57:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/first-date-with-ruby</id>
    <content type="html"><![CDATA[<p>Last night I took a notion into my head and wound up spending a solid few hours with Ruby.
I&rsquo;m happy with how that went! There&rsquo;s some first-time-with-a-new-language friction, but nothing out of the ordinary.
Here&rsquo;s what I came up with, and afterwards, why I chose that and what I think it shows that I accomplished that.</p>

<p><noscript><pre>require &#39;cgi&#39;
require &#39;json&#39;
require &#39;net/http&#39;
require &#39;uri&#39;

module Jekyll
  class MusicLink &lt; Liquid::Tag

    def initialize(tag_name, contents, tokens)
      super
      @contents = contents
    end

    def render(context)
      @affiliateCode = &#39;secret&#39; # Fill in yours!
      page = context.environments.first[&#39;page&#39;]
      if page[&#39;music-artist&#39;] &amp;&amp; page[&#39;music-track&#39;]
        music_url, music_string = getMusic(page[&#39;music-artist&#39;], page[&#39;music-track&#39;])
        return %(&lt;span class=&#39;music-box&#39;&gt;Music: &lt;a class=&#39;music-link&#39; href=&quot;#{music_url}&quot;&gt;#{music_string}&lt;/a&gt;&lt;/span&gt;)
      else
        return %()
      end
    end

    def makeItunesTarget(artist, track)
      iTunesURL = URI(&quot;https://itunes.apple.com/search&quot;)
      iTunesParams = {
        :country =&gt; &quot;us&quot;, :media =&gt; &quot;music&quot;,
        :limit =&gt; &quot;5&quot;, :entity =&gt; &quot;musicTrack&quot;,
        :term =&gt; artist + &quot; &quot; + track,
      }
      iTunesURL.query = URI.encode_www_form(iTunesParams)
      return iTunesURL
    end

    def getFromItunes(iTunesURL)
      http = Net::HTTP.new(iTunesURL.host, iTunesURL.port)
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_PEER

      request = Net::HTTP::Get.new(iTunesURL.request_uri)
      response = http.request(request)
      if response.code == &quot;200&quot;
        jsonResponse = JSON.load(response.body)
        if jsonResponse[&#39;resultCount&#39;] == 0
          jsonResponse = false
        end
      else
        jsonResponse = false
      end
      return jsonResponse
    end

    def makeAnchorFromItunesData(iTunesJSON)
      unless iTunesJSON
        return iTunesJSON, iTunesJSON
      end

      primaryResult = iTunesJSON[&#39;results&#39;].first
      if @affiliateCode
        urlRegex = /(https:\/\/itunes\.apple\.com\/[^?]+\?[^&amp;]+).+/
        urlReplacement = &#39;\1\2&amp;partnerId=30&amp;siteID=&#39; + @affiliateCode
        affiliatedTrackUrl= primaryResult[&#39;trackViewUrl&#39;].sub(urlRegex, urlReplacement)
        primaryResult[&#39;trackViewUrl&#39;] = affiliatedTrackUrl
      end

      anchorURL = primaryResult[&#39;trackViewUrl&#39;]
      anchorString = CGI.escapeHTML(&quot;%s - %s&quot; % [primaryResult[&#39;artistName&#39;], primaryResult[&#39;trackName&#39;]])
      return anchorURL, anchorString
    end

    def getMusic(artist_name, track_name)
      music_url, music_string = makeAnchorFromItunesData(getFromItunes(makeItunesTarget(artist_name, track_name)))
      return music_url, music_string
    end

  end
end

Liquid::Template.register_tag(&#39;music&#39;, Jekyll::MusicLink)
</pre></noscript><script src="https://gist.github.com/brighid/c3d19f2c6749fbec30ed.js?file=itms_music_link.rb"> </script></p>

<p>This creates a new Liquid tag, <code>{% music %}</code>, which can be inserted in page templates.
I added it to my <code>footer.html</code> after the byline, timestamp, and categories.
The tag checks whether the post&rsquo;s YAML front-matter has data for a musician and a track name.
If the post has that data, the plugin attempts to create a link to the iTunes Store for the given track.
With <code>makeItunesTarget()</code> it puts together a URL that is a query to the <a href="http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html">iTunes Store Search API</a>, with <code>getFromItunes()</code> it loads the query URL and hands off the response to the standard library&rsquo;s JSON parser, and with <code>makeAnchorFromItunesData()</code> it takes the first search result and generates text to use for an <code>&lt;a&gt;</code> tag and a URL to use for the tag&rsquo;s <code>href</code> attribute (if you have an affiliate code for the iTunes store, it&rsquo;ll be inserted).
Finally, there&rsquo;s a convenience function, <code>getMusic()</code>, that just composes the previous three.</p>

<p>Part of why this worked well is that it&rsquo;s another project with limited scope: I had a specific objective in mind, so I was able to keep moving gradually towards it.
However, that limited scope was a way of making progress towards the broad goal of &ldquo;learn Ruby&rdquo; and also took on the medium-scope goal of &ldquo;learn the iTunes Store Search API.&rdquo;
As a practical matter, learning to work with other people&rsquo;s APIs, whether they&rsquo;re libraries, services, or daemons, is an important skill for a working programmer; toy projects that include cultivating that skill are good uses of my time.
Learning new languages is also a career-long thing: for all the talk of Lisp being &ldquo;the hundred-year language,&rdquo; no-one now working as a programmer will be programming in just one language for the rest of their days.
There are shell scripts and libraries and wrappers: there is a fragmented world that despite the friction of fragmentation, would not actually be better-served by a language monoculture.
In addition, there are plenty of exciting things out there whose roots are in Ruby, so I was enthusiastic about picking up a smattering of Ruby.</p>

<p>I&rsquo;m definitely fond of Ruby so far.
Part of this is because I&rsquo;m getting to the point where I&rsquo;m seeing parallels with other languages and able to make good guesses about how a new language will behave.
I was able to guess from reading source &ldquo;oh okay, Ruby is one of the languages where the return value of a function, if not explicit, is the value of the last statement evaluated in its body,&rdquo; was pleasantly surprised that it has the same tuple-packing return-multiple-values feature as Python, and noticed &ldquo;oh hey neat, there&rsquo;s a Scheme-like <code>function!()</code> naming convention for functions that mutate their parameters.&rdquo;
So that&rsquo;s all good stuff.</p>

<p>Part of choosing Ruby, too, is that I&rsquo;m currently blogulating via Octopress, which is built on Ruby.
Most of why I chose it is that Wordpress is awful (on the axes I care about), but now that I&rsquo;ve chosen it, I want to have a grasp of how it works.
That means learning Ruby and tinkering&mdash;which I&rsquo;m looking forward to.</p>

<p>As a supplemental note, if this stuff sounds to you like a good attitude for a programmer to have, you should <a href="http://careers.stackoverflow.com/stronglyemergent">hire me</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Weekend project: affiliate.el]]></title>
    <link href="http://stronglyemergent.com//blog/2013/weekend-project-affiliate-dot-el/"/>
    <updated>2013-03-21T20:16:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/weekend-project-affiliate-dot-el</id>
    <content type="html"><![CDATA[<p>Since I&rsquo;m searching for a new job (<a href="http://careers.stackoverflow.com/stronglyemergent">check out my CV on Stack Overflow Careers!</a>),
I&rsquo;ve been trying to gin up little personal projects and to extract what publishable code I can from my work projects.
The first result of this is <a href="https://github.com/brighid/affiliate.el">affiliate.el</a>.
It&rsquo;s a small project - very small - but it has virtues that I think make it a good component of a GitHub portfolio.</p>

<p>First, the smallness is advantage: it is a project with a <em>small, well-defined scope</em>.
That&rsquo;s important.
Projects with a large scope are prone to taking a long time, and projects with a poorly-defined scope are almost by definition a bad idea
(making a note that fail-fast rapid-iteration work is a totally reasonable thing).
The scope of this project
is &ldquo;automatically turn Amazon/iTunes URLs in text into affiliate links by extending emacs.&rdquo;
I chose that because I do the great majority of my writing (including this post) in emacs,
and because I am involved in Amazon and Apple&rsquo;s affiliate-links programs (because I like extra coffee money once in a while just
as well as the next person).
Choosing scope carefully is important for projects that are intended to accomplish a goal
(as opposed to projects where the point is to learn about the problem space, such as the Clojure thing I&rsquo;m messing with)&mdash;
and in professional life, the norm is for projects to be goal-focused.</p>

<p>The other reason that smallness is an advantage is that <code>affiliate.el</code> is small enough for someone else to sit down, read, and fully understand in one sitting.
I want to make it easy for this hypothetical code reviewer to get a grasp on what I&rsquo;ve created.
To that end, this project also demonstrates
&ldquo;behold, I write friendly code: there are clear docstrings, there is an approachable readme, and the commit messages are concise and helpful.&rdquo;
I think that this is an important skill for an engineer to have too, because coding work happens in a social context.
Your ability to explain your work to other engineers&mdash;
and to others in general&mdash;is crucial to its value being recognized.
So I want to show with this project &ldquo;I can make my code accessible to others.&rdquo;</p>

<p>Of course, those virtues only really shine in the context of good solid working code.
This too I think the project demonstrates: concise, workmanlike, idiomatic elisp with a suite of unit tests.
This code is well-formed for its environment:
it uses built-in emacs features such as <code>customize</code> and <code>provide</code> like a good citizen of its ecosystem,
it doesn&rsquo;t re-invent any wheels or require any esoteric libraries,
and it uses unit tests to demonstrate and hew to the requirements for input and output.
It is not heroic code, it&rsquo;s just solid, humble, functional code.</p>

<p>There probably aren&rsquo;t very many people to whom this little emacs module is useful as executable code,
but I&rsquo;m fine with that as long as it&rsquo;s useful for saying something about its creator.
Especially if that thing is <a href="http://careers.stackoverflow.com/stronglyemergent">&ldquo;hire this person.&rdquo;</a></p>
]]></content>
  </entry>
  
</feed>

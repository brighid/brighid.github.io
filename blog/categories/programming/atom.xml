<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Strongly Emergent]]></title>
  <link href="http://stronglyemergent.com//blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://stronglyemergent.com//"/>
  <updated>2015-11-28T03:31:05-08:00</updated>
  <id>http://stronglyemergent.com//</id>
  <author>
    <name><![CDATA[Strongly Emergent Systems]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Two Traps]]></title>
    <link href="http://stronglyemergent.com//blog/2013/two-traps/"/>
    <updated>2013-07-02T14:25:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/two-traps</id>
    <content type="html"><![CDATA[<p>Joel Spolsky famously opined that you should look for two things when hiring a programmer:
<a href="http://www.joelonsoftware.com/articles/GuerrillaInterviewing3.html">Smart, and Gets Things Done</a>. Now, there are a lot of smart people in the world (with a
nod in the direction of <a href="http://en.wikipedia.org/wiki/Cattell%E2%80%93Horn%E2%80%93Carroll_theory">the fox/hedgehog debate</a>), and plenty of them spend some time
programming. Even though there are also a great many people who think themselves smarter than they
are, there is a thriving body of lore on filtering that demographic out. So most of the task of
evaluating programmers is about evaluating how and if they Get Things Done.</p>

<p>Evaluating yourself this way is a good skill to have; lately I&rsquo;ve been trying to build more and
tinker more on account of being less-than-fully satisfied with what I see in my
self-evaluation. I&rsquo;ve also noticed two failure modes that smart programmers may fall into (one of
which I&rsquo;m doing my darndest to avoid), running parallel to the symbols-versus-understanding sides
of the <a href="http://en.wikipedia.org/wiki/Chinese_room">Chinese Room Argument</a>. The argument, oversimplified, is about whether or not
it&rsquo;s possible to infer that an unseen conversational partner who manipulates symbols correctly,
<em>understands</em> the communication.</p>

<p>A self-taught programmer is proficient in manipulating symbols, but is vulnerable to the failure
mode of not <em>understanding</em> them, of having a <a href="http://me.veekun.com/blog/2011/04/16/architectural-fallacies/#the-xy-problem">myopia about methods and goals</a>. On the
other hand, engineers who&rsquo;ve been involved in trying to hire from university computer science
departments can attest that CS shops produce a certain proportion of people who understand why all
of those symbol-manipulation rules are what they are, and who know a great deal about the rules and
how they are implemented, but who are curiously unable to actually perform the manipulation of
symbols and the latching-together of symbols into structures&mdash;no GitHub account, no projects of
their own, no open-source contributions.</p>

<p>I&rsquo;m nothing like the first person to notice these failure modes, but I think that identifying them
as such (<em>not</em> as &ldquo;all self-taught programmers are flaky&rdquo; or &ldquo;a CS degree is superfluous&rdquo;) is
helpful. Identifying a problem opens up the possibility of solving it. For me, it was humbling to
stumble on the Chinese Room Argument and realize that while I&rsquo;m good at manipulating the symbols,
that is not the same as fluency and I have a lot of work to do ahead of me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Negative 100 Points]]></title>
    <link href="http://stronglyemergent.com//blog/2013/negative-100-points/"/>
    <updated>2013-06-28T20:07:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/negative-100-points</id>
    <content type="html"><![CDATA[<p>A <a href="http://blogs.msdn.com/b/ericgu/archive/2004/01/12/57985.aspx">short post by Eric Gunnerson</a>
about designing C#, nearly a decade old now, has stuck with me for a long time.</p>

<blockquote><p>[the question] implies that we started with an existing language (C++ and Java are the popular
choices here), and then started removing features until we got to a point where we liked. That&rsquo;s
not how the language got designed. One of the big reasons we didn&rsquo;t do this is that it&rsquo;s really
hard to remove complexity when you take a subtractive approach, as removing a feature in one area
may not allow you to revisit low-level design decisions, nor will it allow you to remove
complexity elsewhere, in places where it support the now-removed feature. We decided on the
additive approach instead, and worked hard to keep the complexity down. One way to do that is
through the concept of &ldquo;minus 100 points.&rdquo; Every feature starts out in the hole by 100 points,
which means that it has to have a significant net positive effect on the overall package for it
to make it into the language. Some features are okay features for a language to have, they just
aren&rsquo;t quite good enough to make it into the language.</p></blockquote>

<p>If this sounds familiar, it should: this is another lens on the design philosophy, popularized in
the developer community by Apple, that good design requires saying &ldquo;no.&rdquo; Saying &ldquo;no&rdquo; a <em>lot.</em> I
applaud Apple for applying this philosophy so rigorously&mdash;but it&rsquo;s important to remember that
they&rsquo;re <a href="http://technet.microsoft.com/en-us/magazine/dn167709.aspx">not the only people who use it</a>, and their way is not the only way. What you
say &ldquo;no&rdquo; to, defines you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Prisoner Of Zend, Duh]]></title>
    <link href="http://stronglyemergent.com//blog/2013/the-prisoner-of-zend-duh/"/>
    <updated>2013-06-18T23:30:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/the-prisoner-of-zend-duh</id>
    <content type="html"><![CDATA[<p>It is surely not news to you that PHP is awful: there is a thriving sub-genre of tech blog posts
about how very, very bad PHP is. It should tell you something about what a clown rodeo PHP is that
even in the presence of Eevee&rsquo;s magisterial <a href="http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/">&ldquo;PHP: A Fractal Of Bad Design&rdquo;</a> article, so
many of us feel compelled to contribute to the vast body of PHP-criticizing literature anyhow. For
my part, even after acknowledging excellent works like &ldquo;Fractal Of Bad Design,&rdquo; man-of-mystery Pi&rsquo;s
<a href="http://two-pi-r.livejournal.com/622760.html?format=light">&ldquo;PHP is a low-level programming language at the wrong level,&rdquo;</a> and Watts Martin&rsquo;s
pungently-named <a href="http://tracks.ranea.org/post/13908062333/php-is-not-an-acceptable-cobol">&ldquo;PHP is not an acceptable COBOL,&rdquo;</a> all written by pals who are smarter than
I am, I still am called to add to the discourse. There are plenty of languages that one may
dislike, and there are plenty of warts on any language one does like&mdash;and yet, PHP is <em>sui
generis</em> in its terribleness.</p>

<p>Before starting in on my own complaints, I&rsquo;m going to stop and acknowledge another rant: during
Leonard Pierce&rsquo;s delightfully <a href="http://ludickid.livejournal.com/914741.html?format=light">funny and acerbic chronicle of hating Billy Joel</a>, there
is an aside that answers very well the question of why people hate PHP in a way that people almost
never hate JavaScript, C++, or Visual Basic, deeply flawed languages all of them.</p>

<blockquote><p>Just as one can argue that there were better World Series teams than the 1927 New York Yankees,
one can argue that various performers have written worse songs than those produced from the
depressingly fertile mind of Billy Joel. &ldquo;Yummy Yummy Yummy,&rdquo; to cite an older example, is
certainly the product of a nightmarish hatred of all humanity, and arguably worse than any Billy
Joel song. To cite a more recent example, &ldquo;My Humps&rdquo; offends the soul and mind in ways to which
only the most cretinous songs by the Man from Hicksville can aspire. But while there are those
who can honestly contend that the &lsquo;27 Bronx Bombers were not the greatest of all World Series
teams, no one&mdash;not even those who hate the Yankees with a soul-scorching fire, as do all
right-thinking humans&mdash;can argue that they are not the best baseball franchise ever. The numbers
simply speak for themselves. No other team has even remotely come close to topping their total
number of world championships. Similarly, no other performer or group has ever had so many
horrible songs become so successful on the charts as has Billy Joel. <strong>Others have been worse;
others have been bigger. But no one has been bigger and badder at the same time than Billy
Joel.</strong></p></blockquote>

<p>No one has been bigger and badder at the same time than PHP.</p>

<p>The things that make me most unhappy about PHP center around the fact that software development
does not happen in a vacuum. Our choices as developers affect others, including our future
selves. Most of the substance of the writeups that I&rsquo;ve cited is devoted to PHP&rsquo;s legion of
failings as an abstract tool for computation: they&rsquo;ve got that well-covered. What I want to focus
on is PHP&rsquo;s catastrophic badness as a participant in a living ecosystem of software projects,
tools, and traffic (this is where I think <a href="http://www.codinghorror.com/blog/2008/05/php-sucks-but-it-doesnt-matter.html">Jeff Atwood deeply misjudged PHP</a>). There
are three broad areas of failure here:</p>

<ul>
<li>PHP is the avatar of technical debt</li>
<li>The flagship PHP projects are bad examples</li>
<li>PHP&rsquo;s flaws grievously pollute the commons</li>
</ul>


<p>In all three of these areas, my beef is the effects that PHP-the-language and PHP projects have on
the world around them. The ways in which PHP is broken as a tool for computation, lead directly to
the ways in which the software written in PHP is broken as a tool for improving people&rsquo;s lives.</p>

<h3>The Avatar Of Technical Debt</h3>

<p>One of the most visible ripple effects of PHP is the effect is has on maintenance programmers and
on &ldquo;consumers&rdquo; of code. Even stipulating that the newest versions of PHP are tremendous
improvements on PHP4, legacy code is still a thing in general, and PHP&rsquo;s specific shape makes it
more of a problem for PHP than in the general case. Because of the tremendous obstacles to setting
up something like Python&rsquo;s <code>virtualenv</code> or Ruby&rsquo;s <code>rbenv</code> in the PHP world, the uptake of new
versions of PHP is disproportionately impaired by the most out-of-date libraries or language
features being used. &ldquo;Past technical decisions making it harder to make the right technical
decisions in the present&rdquo; is pretty much the definition of <a href="http://c2.com/cgi/wiki?TechnicalDebt">technical debt</a>.</p>

<p>The obstacles don&rsquo;t have to be insurmountable to keep people from upgrading. It just has to have
friction somewhere in the process. The difference between &ldquo;easy enough that people can do it&rdquo; and
&ldquo;easy enough that people <em>do</em> do it,&rdquo; is significant. PHP is on the wrong side of that difference:
breaking changes have been introduced in minor versions, for example. And the bigger the PHP
codebase you&rsquo;re maintaining, the slower your upgrades will be, because you have a ton of surface
area to deal with and you can&rsquo;t use something like <code>virtualenv</code> or <code>rbenv</code> to attempt an
incremental update of either PHP itself or of any library or C module you may happen to be
using. The cost of upgrading rises faster than with other languages because of this: you have fewer
ways to escape dependency traps.</p>

<p>On top of this, PHP has enough gotchas, pitfalls, and required boilerplate that reading it
carefully is difficult. You don&rsquo;t need to read code like this all the time, but there are times
when you absolutely will need to read code like this&mdash;the most benign example is when you pick up
your own code that you haven&rsquo;t worked with for a while, but you&rsquo;ll also read code this way when
you&rsquo;re reviewing it in an appsec-centric state of mind. PHP makes this task harder, and so
artificially increases the amount of technical debt you take on, whether you&rsquo;re working with your
own code or others'. Which version of PHP was this file written against? Does this function require
a particular <code>ini_set()</code> invocation that could be clobbered elsewhere? Does this if-block behave
correctly when the result of an expression is <code>0</code> instead of <code>FALSE</code>? Does all the code use <code>===</code>
instead of <code>==</code>? Does this function behave acceptably if one of its variables gets clobbered by a
global?</p>

<p>Maintaining PHP code has too much friction for people to do so diligently in practice. This is why
the &ldquo;you can write FORTRAN in any language&rdquo; rebuttal to criticisms of PHP is so utterly bankrupt:
PHP does not just make it <em>possible</em> to write bad code, its quirks actively make it harder to write
good code.  One of Perl&rsquo;s slogans is that the language &ldquo;makes easy things easy and hard things
possible.&rdquo; PHP, as though coming from a mirror universe with a sinister goatee, makes easy things
hard (behold the <a href="http://phpsadness.com/sad/52">absolute train wreck</a> of PHP&rsquo;s comparison operators) and
<a href="http://software-gunslinger.tumblr.com/post/48215406921/php-is-meant-to-die-continued">hard things impossible</a> (largely because <a href="http://software-gunslinger.tumblr.com/post/47131406821/php-is-meant-to-die">PHP is meant to die</a>). In a
perversion of good language design, a concise and readable piece of PHP is <em>more</em> likely to have
bugs, not less. I call PHP the avatar of technical debt because using PHP at all is incurring
tremendous technical debt that comes from this friction with libraries and ensuring good code. You
can write good code in PHP&mdash;but it&rsquo;s harder to <em>know</em> that you&rsquo;ve written good code, the good code
will be longer, and the cost of updating the language and libraries makes it harder to get good
code into production.</p>

<p>Critically, this technical debt is almost always an <a href="http://en.wikipedia.org/wiki/Externality#Negative">externality</a>: it is a cost
that the person writing the code doesn&rsquo;t have to pay. Instead, the cost is borne by future
engineers and users who might as well be strangers. Beware of externalities! If you are not paying
the real, full costs of your decisions, <a href="http://en.wikipedia.org/wiki/Moral_hazard">you will be led to make bad decisions</a>.
Because PHP fails to make the right thing easy, it tends to make the wrong thing the default&mdash;and
the costs of dealing with the wrong thing are all too often externalized, whether that&rsquo;s from a
coder to their future self, from an engineer to a sysadmin, or from a vendor to the users of
software.</p>

<h3>Don&rsquo;t Follow The Leader</h3>

<p>When the question of PHP&rsquo;s awfulness comes up, inevitably someone tries to use Wikipedia, Facebook,
and WordPress as examples of PHP&rsquo;s success. Even if you leave aside how that&rsquo;s like saying that
Harvard is an average American university, Wikipedia, Facebook, and WordPress all have significant
problems that are directly attributable to their decision to use PHP! If you are not prepared to
deal with those problems, then you had better not use PHP. The fact that Wikipedia, Facebook, and
WordPress are all built on PHP is <em>insufficient</em> to demonstrate that you personally should use PHP
for anything: you have to know more about how those projects work and the tradeoffs they made, to
know if their use of PHP recommends PHP for your application.</p>

<!-- Spoilers: It doesn't. -->


<p>Wikipedia is the easiest example to pick on here, because they provide all the damning evidence
themselves. Go and check out a copy of the MediaWiki source code (I&rsquo;m going to treat &ldquo;Wikipedia&rdquo;
and &ldquo;MediaWiki&rdquo; as mostly synonymous here) and take a look at it. Reflect on how many
engineer-hours it took to get the project to that state, and how many more hours are being
requested. Reflect on the contents of their <a href="http://www.mediawiki.org/wiki/Annoying_large_bugs">&ldquo;Annoying Large Bugs&rdquo;</a> and
<a href="https://www.mediawiki.org/wiki/Annoying_little_bugs">&ldquo;Annoying Little Bugs&rdquo;</a> pages. If you want to use Wikipedia as a role model, being
blind to Wikipedia&rsquo;s flaws is a terrible idea.</p>

<p>Because Wikipedia is such a high-profile target (huge PageRank points, huge repository of
user-generated content, huge mindshare) there&rsquo;s a <a href="http://www.cvedetails.com/vendor/2360/Mediawiki.html">steady record of vulnerabilities</a>
with MediaWiki. If you get into the plumbing of Wikipedia, get under the layer that just presents
pages to visitors, get familiar with the greasy-handed wiki-gnomes, you&rsquo;ll find all kinds of
interesting infrastructure designed to cope with this. I wouldn&rsquo;t like to see anyone argue that
Wikipedia is a bad project. It&rsquo;s a triumph of the open-source ethos, and an incalculably valuable
community resource for the entire Internet-using population. But as an engineering project, you
should be very careful about emulating it. You should make sure that you can invest proportionate
engineer-hours into security and maintenance&mdash;and that you account for how a PHP-based project
needs more of those hours.</p>

<p>Speaking of gigantic quantities of engineer-hours, there&rsquo;s Facebook. Facebook is an even worse
choice as an example of PHP&rsquo;s success, because Facebook has effectively forked PHP. Look at their
<a href="https://github.com/facebook/hiphop-php">HipHop PHP</a> project: it&rsquo;s replacing the default PHP interpreter wholesale, and
replacing Apache/<code>mod_php</code> as well. You shouldn&rsquo;t use Facebook as evidence that your project should
use PHP, because the way you use PHP is not like the way that Facebook uses PHP. Facebook basically
ended up writing their own entire PHP toolchain! This is probably not the way you want to go for
your project.</p>

<p>On top of that, there are ways in which Facebook&rsquo;s usage of PHP is dubious, or at least suggests
that they would rather not be using PHP. Before the current version of HipHop, which is a VM that
executes PHP, they were cross-compiling to C++. When &ldquo;cross-compile to C++&rdquo; makes your project less
painful, that&rsquo;s a bad sign. This loops back to the &ldquo;avatar of technical debt&rdquo; thing. Facebook at
this point is <em>trapped</em> in PHP and making the best of it: they have a bigger PHP codebase to
maintain, so they&rsquo;re more trapped. They&rsquo;re up to the point where they&rsquo;re compiling PHP and doing
static-analysis optimization on it&mdash;which is to say, they are doing
<a href="http://www.research.ibm.com/trl/people/mich/pub/200901_popl2009phpsem.pdf">original computer-science research</a>, because PHP&rsquo;s internals are that much of a
mess.</p>

<p>WordPress is also not a good PHP role model: it&rsquo;s gotten better over time, but the direction of its
evolution is away from &ldquo;blog&rdquo; and towards &ldquo;maximalist content management system,&rdquo; which means
expanding the attack surface. WordPress is actually less of a bad PHP role model than Wikipedia and
Facebook: rather than being a giant application hosted and administered by Someone Else, WordPress
is a PHP application that you can download, install, and investigate for yourself. They&rsquo;ve invested
a lot of effort in making that part easy.</p>

<p>Unfortunately, &ldquo;easy PHP&rdquo; is pretty much always &ldquo;insecure PHP.&rdquo; So WordPress has a
<a href="http://osvdb.org/search?search[vuln_title]=wordpress&amp;search[text_type]=alltext">long track record of nasty vulnerabilities</a>. It&rsquo;s also saddled with a
reputation for spam&mdash;being the easy choice, a platform that you can set up yourself with no
gatekeeper (compare to Movable Type, professionally hosted WordPress installations, or Blogger
instances), it&rsquo;s become the choice for people who want to automatically deploy large numbers of
WordPress instances targeted to specific content/keyword niches. Then there&rsquo;s the architecture
matter: maybe this is just taste, but I find things like <code>rewind_posts()</code> inherently suspect (and
there are <a href="http://www.reddit.com/r/lolphp/comments/1etq3n/wordpress_will_automatically_convert_foo_to_foo/">unproven allegations</a> of grotesque features lurking in the codebase). More
substantially, there&rsquo;s mutable global state lurking all over the place (on top of the distressing
action-at-a-distance issues PHP inherently has&mdash;see Eevee&rsquo;s writeup for more about that), the app
buys into <a href="http://www.reddit.com/r/lolphp/comments/1dzvjk/wordpress_core_is_secure_stop_telling_people/c9vlcpi">the &ldquo;sanitize input&rdquo; voodoo</a>, and like most PHP apps, it requires a bunch of
read-and-write access to its environment that a better app wouldn&rsquo;t. This is part of the ongoing
security problem WordPress faces&mdash;which leads us to talking about PHP&rsquo;s role in software platforms
and ecosystems.</p>

<h3>The Superfund Site Of Programming Languages</h3>

<p>At this point we need to get abstract for a minute. Part of why infosec is important is that we do
not create, modify, or use software in isolation. We interact with software in a social context, in
a technological context, in a networked context. Similar to how herd immunity in medicine means
that the chance of catching a particular disease is unevenly distributed, software vulnerabilities
are dangerous even to people who aren&rsquo;t running the affected software. The most common thing that
an attacker might do with a compromised machine is suborn its resources, using it to propagate
further attacks (e.g. having it join a botnet). This is why it&rsquo;s particularly dismaying that PHP is
so big and so bad: even if I don&rsquo;t run anything based on PHP myself (or based on its
<a href="http://grimoire.ca/mysql/choose-something-else">co-conspirator in suckitude</a>, MySQL), PHP is still a problem for me.</p>

<p>The problem is severe, too. A security researcher finds that of sites vulnerable to password dumps,
<a href="http://blog.passwordresearch.com/2013/02/passwords-found-in-wild-for-january-2013.html">most are built on PHP</a>. A remote-code-execution vulnerability in two of the most
popular WordPress plugins is discovered&mdash;and the subsequent patches have an
<a href="http://hackertarget.com/running-wordpress-patch-your-plugins/">utterly dismal uptake rate</a>. There are a multitude of PHP-based server control
panels that have deeply <a href="http://seclists.org/fulldisclosure/2013/Apr/139">disturbing security problems</a> of
<a href="http://www.reddit.com/r/programming/comments/1gfve8/how_not_to_handle_a_critical_security/">grave severity</a>. A search on GitHub reveals a multitude of PHP projects open to a
<a href="https://github.com/search?p=1&amp;q=extension%3Aphp+mysql_query+%24_GET&amp;ref=searchresults&amp;type=Code">trivial SQL injection</a> attack. A bug in parsing URLs&mdash;surely an action that should
be a core competency for a &ldquo;web language&rdquo;!&mdash;turns out to be
<a href="https://www.idontplaydarts.com/2013/06/http-parameter-pollution-with-cookies-in-php/">implemented in the shoddiest way</a>.</p>

<p>The popularity of apps like WordPress exacerbates the security problems: WordPress has become a
<em>platform</em> as much as it is an app, and the difficult transition from app to platform, it has had
trouble with. When you run WordPress, the potential problems are determined not by the worst code
you wrote nor the worst code that the WP team wrote, but by the union of that code and
<a href="http://thedailywtf.com/Articles/Pot-o-Gold.aspx">the worst code</a> that the authors of any plugin or theme you use wrote. There are a
<em>huge</em> number of WordPress themes and plugins, and they can effectively run anything&mdash;my favorite
example is <a href="http://wordpress.org/plugins/repress/">RePress</a>, which staples a web proxy onto the side of your blog for the
use of folks in locales where services like Google and Wikipedia are blocked. WordPress is a
particularly problematic example because its target audience is non-engineering users. Someone who
sets up an instance of MediaWiki, Joomla, or Drupal faces a higher barrier to entry than a
WordPress user, who is the beneficiary of vigorous and successful efforts to make WordPress
accessible to a wide audience.</p>

<p>Unfortunately, that experience of easy-to-install software ends up recapitulating the experience of
the Windows 9x era: it&rsquo;s easy to install something that creates an opportunity for attackers, and
not easy to tell ahead of time which things you install belong in that category. In WordPress'
case, some of its most high-profile plugins, like the <a href="http://www.hyphenet.com/blog/2013/02/01/hackers-still-scanning-for-vulnerable-timthumb-scripts/">TimThumb image resizer</a> and the
caching plugins discussed earlier (and by the way it speaks very poorly of WordPress that two of
the most popular plugins are caching hacks attempting to work around WordPress' run-time
inefficiency), have seen remote-code-execution vulnerabilities that can be exploited at scale, by
botnets&mdash;and which are particularly likely to succeed against users of WordPress whose blogs and
their upkeep are not an every-waking-moment concern.</p>

<p>I worked with <a href="http://seclists.org/fulldisclosure/2009/Feb/255">Magento</a> professionally for a while, and one thing that gave me
massive creepy-crawlies about it was that it has the same problem as WordPress in the form of a
wild and problematic plugin ecosystem, but centered around an app that&rsquo;s meant to be handling
people&rsquo;s credit-card information. &ldquo;All the security of WordPress, but handles credit-card data!&rdquo;
does not inspire confidence. At least with eBay now running the show, there&rsquo;s a good chance that
Magento will have the budget to shape up security-wise.</p>

<p>If the problems I&rsquo;ve been talking about only affected the people actually running that software,
I&rsquo;d care far less. It&rsquo;s important that people have to some extent the right to make their own dang
mistakes. But these things don&rsquo;t happen in a vacuum. Every unpatched MediaWiki install sitting
around, every forgotten WordPress instance, every homebrew app quietly chugging away, is
susceptible to becoming part of a botnet and worsening the state of the entire Internet. Every
machine that gets rooted, is another machine conducting attacks of one kind or another&mdash;and even
if I run my own servers on the magical free-ponies language of sparkles and no security
vulnerabilities ever, a legion of zombie PHP-running boxes can still just throw denial-of-service
attacks my way until it doesn&rsquo;t matter what I&rsquo;m running.</p>

<p>This is why it matters that PHP is both big and bad: by being both ubiquitous and insecure, it
pollutes the commons. It adds unncessary cost and friction to any project we undertake that&rsquo;s
connected to the Internet&mdash;that is to say, nearly everything. Every server that connects to the
Internet has its attack surface artificially enlarged because PHP&rsquo;s own attack surface is so
vast. Programming doesn&rsquo;t happen in a vacuum, it happens in an ecosystem&mdash;an ecosystem that
PHP-based systems have a long and terrifying track record of dumping nuclear waste into.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Date With Ruby]]></title>
    <link href="http://stronglyemergent.com//blog/2013/first-date-with-ruby/"/>
    <updated>2013-06-15T08:57:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/first-date-with-ruby</id>
    <content type="html"><![CDATA[<p>Last night I took a notion into my head and wound up spending a solid few hours with Ruby. I&rsquo;m
happy with how that went! There&rsquo;s some first-time-with-a-new-language friction, but nothing out of
the ordinary. Here&rsquo;s what I came up with, and afterwards, why I chose that and what I think it
shows that I accomplished that.</p>

<p><div><script src='https://gist.github.com/5788557.js'></script>
<noscript><pre><code></code></pre></noscript></div>
</p>

<p>This creates a new Liquid tag, <code>{% music %}</code>, which can be inserted in page
templates. I added it to my <code>footer.html</code> after the byline, timestamp, and categories. The tag
checks whether the post&rsquo;s YAML front-matter has data for a musician and a track name. If the post
has that data, the plugin attempts to create a link to the iTunes Store for the given track. With
<code>makeItunesTarget()</code> it puts together a URL that is a query to the
<a href="http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html">iTunes Store Search API</a>, with <code>getFromItunes()</code> it loads the query URL and hands
off the response to the standard library&rsquo;s JSON parser, and with <code>makeAnchorFromItunesData()</code> it
takes the first search result and generates text to use for an <code>&lt;a&gt;</code> tag and a URL to use for the
tag&rsquo;s <code>href</code> attribute (if you have an affiliate code for the iTunes store, it&rsquo;ll be
inserted). Finally, there&rsquo;s a convenience function, <code>getMusic()</code>, that just composes the previous
three.</p>

<p>Part of why this worked well is that it&rsquo;s another project with limited scope: I had a specific
objective in mind, so I was able to keep moving gradually towards it. However, that limited scope
was a way of making progress towards the broad goal of &ldquo;learn Ruby&rdquo; and also took on the
medium-scope goal of &ldquo;learn the iTunes Store Search API.&rdquo; As a practical matter, learning to work
with other people&rsquo;s APIs, whether they&rsquo;re libraries, services, or daemons, is an important skill
for a working programmer; toy projects that include cultivating that skill are good uses of my
time. Learning new languages is also a career-long thing: for all the talk of Lisp being &ldquo;the
hundred-year language,&rdquo; no-one now working as a programmer will be programming in just one language
for the rest of their days. There are shell scripts and libraries and wrappers: there is a
fragmented world that despite the friction of fragmentation, would not actually be better-served by
a language monoculture. In addition, there are plenty of exciting things out there whose roots are
in Ruby, so I was enthusiastic about picking up a smattering of Ruby.</p>

<p>I&rsquo;m definitely fond of Ruby so far. Part of this is because I&rsquo;m getting to the point where I&rsquo;m
seeing parallels with other languages and able to make good guesses about how a new language will
behave. I was able to guess from reading source &ldquo;oh okay, Ruby is one of the languages where the
return value of a function, if not explicit, is the value of the last statement evaluated in its
body,&rdquo; was pleasantly surprised that it has the same tuple-packing return-multiple-values feature
as Python, and noticed &ldquo;oh hey neat, there&rsquo;s a Scheme-like <code>function!()</code> naming convention for
functions that mutate their parameters.&rdquo; So that&rsquo;s all good stuff.</p>

<p>Part of choosing Ruby, too, is that I&rsquo;m currently blogulating via Octopress, which is built on
Ruby. Most of why I chose it is that Wordpress is awful (on the axes I care about), but now that
I&rsquo;ve chosen it, I want to have a grasp of how it works. That means learning Ruby and
tinkering&mdash;which I&rsquo;m looking forward to.</p>

<p>As a supplemental note, if this stuff sounds to you like a good attitude for a programmer to have,
you should <a href="http://careers.stackoverflow.com/stronglyemergent">hire me</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Weekend project: affiliate.el]]></title>
    <link href="http://stronglyemergent.com//blog/2013/weekend-project-affiliate-dot-el/"/>
    <updated>2013-03-21T20:16:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/weekend-project-affiliate-dot-el</id>
    <content type="html"><![CDATA[<p>Since I&rsquo;m searching for a new job
(<a href="http://careers.stackoverflow.com/stronglyemergent">check out my CV on Stack Overflow Careers!</a>),
I&rsquo;ve been trying to gin up little personal projects and to extract what publishable code I can from
my work projects. The first result of this is
<a href="https://github.com/brighid/affiliate.el">affiliate.el</a>. It&rsquo;s a small project - very small - but it
has virtues that I think make it a good component of a GitHub portfolio.</p>

<p>First, the smallness is advantage: it is a project with a <em>small, well-defined scope</em>. That&rsquo;s
important. Projects with a large scope are prone to taking a long time, and projects with a
poorly-defined scope are almost by definition a bad idea (making a note that fail-fast
rapid-iteration work is a totally reasonable thing). The scope of this project is &ldquo;automatically
turn Amazon/iTunes URLs in text into affiliate links by extending emacs.&rdquo; I chose that because I do
the great majority of my writing (including this post) in emacs, and because I am involved in
Amazon and Apple&rsquo;s affiliate-links programs (because I like extra coffee money once in a while just
as well as the next person). Choosing scope carefully is important for projects that are intended
to accomplish a goal (as opposed to projects where the point is to learn about the problem space,
such as the Clojure thing I&rsquo;m messing with) &mdash; and in professional life, the norm is for projects
to be goal-focused.</p>

<p>The other reason that smallness is an advantage is that <code>affiliate.el</code> is small enough for someone
else to sit down, read, and fully understand in one sitting. I want to make it easy for this
hypothetical code reviewer to get a grasp on what I&rsquo;ve created. To that end, this project also
demonstrates &ldquo;behold, I write friendly code: there are clear docstrings, there is an approachable
readme, and the commit messages are concise and helpful.&rdquo; I think that this is an important skill
for an engineer to have too, because coding work happens in a social context. Your ability to
explain your work to other engineers - and to others in general - is crucial to its value being
recognized. So I want to show with this project &ldquo;I can make my code accessible to others.&rdquo;</p>

<p>Of course, those virtues only really shine in the context of good solid working code. This too I
think the project demonstrates: concise, workmanlike, idiomatic elisp with a suite of unit
tests. This code is well-formed for its environment: it uses built-in emacs features such as
<code>customize</code> and <code>provide</code> like a good citizen of its ecosystem, it doesn&rsquo;t re-invent any wheels or
require any esoteric libraries, and it uses unit tests to make demonstrate and hew to the
requirements for input and output. It is not heroic code, it&rsquo;s just solid, humble, functional code.</p>

<p>There probably aren&rsquo;t very many people to whom this little emacs module is useful as executable
code, but I&rsquo;m fine with that as long as it&rsquo;s useful for saying something about its
creator. Especially if that thing is
<a href="http://careers.stackoverflow.com/stronglyemergent">&ldquo;hire this person.&rdquo;</a></p>
]]></content>
  </entry>
  
</feed>

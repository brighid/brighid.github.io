<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Strongly Emergent]]></title>
  <link href="http://stronglyemergent.com//blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://stronglyemergent.com//"/>
  <updated>2017-10-30T21:34:41-07:00</updated>
  <id>http://stronglyemergent.com//</id>
  <author>
    <name><![CDATA[Strongly Emergent Systems]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to make SQLAlchemy pass connection flags to a SQLite database via file:// URI query parameters]]></title>
    <link href="http://stronglyemergent.com//blog/2016/how-to-make-sqlalchemy-pass-connection-flags-to-sqlite/"/>
    <updated>2016-08-10T15:53:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2016/how-to-make-sqlalchemy-pass-connection-flags-to-sqlite</id>
    <content type="html"><![CDATA[<p>(<em>for just the code promised by the title, see <a href="https://gist.github.com/brighid/42ed997016973e16bd04df22bfd638f7">this GitHub gist</a>.</em>)</p>

<p>Making software is more work than just sitting down and writing code.
For the code you&rsquo;ve written to matter, you have to make it available to others.
Like prose or visual art, there is no &ldquo;done&rdquo; with software projects: there is only Good Enough.
Unlike prose or visual art, a software project can raise its standard of Good Enough over time by releasing new versions of the code with bug-fixes and new features.
This is where the &ldquo;make it available to others&rdquo; part starts being very difficult.
Active projects, by releasing new versions, always end up in a state of heterogeneity where not all of the project&rsquo;s users are using the same version of the project.
When active projects are incorporated into larger projects, it exacerbates the problem.
It&rsquo;s very common for active projects to advance very far as a standalone project, but to lag very far behind that advancement as part of a larger project.
Sometimes this is very difficult for users.
But it is not any one person&rsquo;s fault: it is, overwhelmingly, the emergent result of how projects interact with each other.
Today I&rsquo;m going to show how this process leads to the preÃ«minent database/ORM library in the Python world, <a href="http://www.sqlalchemy.org/">SQLAlchemy</a>, being unable to take advantage of a nearly decade-old feature of <a href="https://www.sqlite.org/">SQLite</a>, a widely-used database.</p>

<p>Let&rsquo;s start with SQLite.
Like most database systems, SQLite lets you provide connection flags (extra information) when you connect to a database.
By sending connection flags (e.g. <code>SQLITE_OPEN_READONLY</code> or <code>SQLITE_OPEN_CREATE</code>) you can have the database itself enforce restrictions on your interactions with it.
Being able to send connection flags is very helpful for programmers.
Having the database enforce the restrictions that the connection flags signify means you don&rsquo;t need to write your own enforcement code.
It also eliminates the chance of making mistakes while writing enforcement code.
You gain productivity because the time that writing and checking enforcement code would take, you can instead spend on writing other code.</p>

<p>SQLite added connection flags in version 3.5.0 (Fall 2007).
However, SQLite is a C project, not a Python project.
The connection flags are concepts that exist in SQLite&rsquo;s C code.
For them to exist in other languages, those languages (or their ecosystems) must provide a way of interacting with SQLite that permits specifying &ldquo;please send the following connection flags when you connect to the SQLite database.&rdquo;</p>

<p>Plenty of other languages already had tools for interacting with SQLite in 2007, based on a function named <code>sqlite3_open()</code>.
Because there was already plenty of software using <code>sqlite3_open()</code> and relying on its existing behavior (SQLite&rsquo;s first public release was Spring 2000), SQLite 3.5.0 also introduced a new function, <code>sqlite3_open_v2()</code>, that understood connection flags.
This allowed users to keep using <code>sqlite3_open()</code> until they were ready to change their code to use <code>sqlite3_open_v2()</code>.
Once they began using the new function, they&rsquo;d be able to use the new features.
In <a href="https://www.sqlite.org/releaselog/3_7_7.html">version 3.7.7</a> (Summer 2011), SQLite made it easier still to use the new features by teaching both the old and new versions of <code>sqlite3_open()</code> to, with a little coaxing, understand <code>file://</code> URLs<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> as well as file paths.
File paths are specific to a particular operating system or family of them, but <code>file://</code> URLs are OS-independent.
This made life slightly easier in general, but using <code>file://</code> URLs had a more important benefit as well.
Using them made it much easier to send connection flags, because SQLite permitted users to put connection flags in the <code>file://</code> URL.
Effectively, both versions of <code>sqlite3_open()</code> could now understand connection flags.
SQLite also added some <a href="https://www.sqlite.org/c3ref/open.html#urifilenamesinsqlite3open">connection flags that could <em>only</em> be used by embedding them in a <code>file://</code> URL</a>.</p>

<p>If you were writing Python instead of C, though, you couldn&rsquo;t count on having access to SQLite&rsquo;s improvements.
Python&rsquo;s support for SQLite comes from periodically incorporating code from the independent <code>pysqlite</code> project.
The <code>sqlite3</code> module in Python&rsquo;s standard library (introduced with Python 2.5&rsquo;s release, Fall 2006) is a lightly modified version of <code>pysqlite</code>.
Python 2.7 (Summer 2010) <a href="https://github.com/python/cpython/commit/b53996dead8c6a602d3f4f6c73bdd4573d0e49sef">contained version 2.6.0 of <code>pysqlite</code></a> (Spring 2010).
This version remains the core of <code>sqlite3</code> as of Python 2.7.11 (Winter 2015) and Python 3.5.2 (Summer 2016).
There does not yet exist a version of Python where the following code works<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>:</p>

<pre><code>import sqlite3
sqlite3.connect("file:///path/to/my/database.db")
</code></pre>

<p>There <em>are</em> workarounds, but they show how challenging it can be to get new versions of software projects into users' hands.
Fundamentally, the Python code above fails because SQLite, in the process of teaching the <code>sqlite3_open()</code> functions to understand <code>file://</code> URLs, chose to make the new feature opt-in (similar to how they distinguished between <code>sqlite3_open()</code> and <code>sqlite_v2_open</code>).
There are three times when you can opt into having SQLite understand <code>file://</code> URIs: during its compilation, when it launches, and when you call it.
The <code>sqlite3</code> module, in its <code>pysqlite</code> version 2.6.0 incarnation, avails itself of none of them.
It also provides no way for users to opt in.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>
As an independent project, <code>pysqlite</code> released version 2.8.2 (Spring 2015), which <a href="https://github.com/ghaering/pysqlite/commit/46d999e5302fb58d9636759ff36e0875c0c1eeb2">added a way for users to send any connection flags</a> SQLite understands.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>
This version is not part of Python, however, and is only available for use as a standalone module when using 2.x versions of Python.
Early versions of Python 3 were also stuck with the no-URIs behavior.
Python 3.4 (Spring 2014) introduced a way to tell <code>sqlite3.connect()</code> that it should treat its input as a URL.<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>
Unlike <code>pysqlite</code>&rsquo;s improved version, the Python 3.4 change didn&rsquo;t add a general way to send flags (though it did open up the &ldquo;send flags as part of a <code>file://</code> URL&rdquo; path).
Still, by mid-2015, if you were using <code>sqlite3</code>, you had a fairly good chance of being able to use connection flags.</p>

<p>There are a lot of people using SQLite who <em>aren&rsquo;t</em> using <code>sqlite3</code>, though, at least not directly.
Because of how easy it is to create bugs, some of which will be disastrous security holes, and because of how tedious it can be to write raw SQL queries, the overwhelming (and correct) consensus of the Python community is that you should use SQLAlchemy to interact with your database.
SQLAlchemy also connects to databases via URLs, but given that its decision to use URLs predates SQLite&rsquo;s by years (<a href="https://github.com/zzzeek/sqlalchemy/commit/0f42441edd8269308ec1b3c9936759a289dee826">SQLAlchemy version 0.1.0</a>, Winter 2005-06), it should be unsurprising that the two usages clash.
SQLAlchemy wants users to identify databases by URLs with the database name as the schema.
So the database in our example above would be <code>sqlite:///path/to/my/database.db</code>.
SQLAlchemy&rsquo;s database-URL schemas can have extra information (query parameters) in them, like SQLite&rsquo;s <code>file://</code> URLs, which tell it how to connect to the database.
The connection isn&rsquo;t done by SQLAlchemy, though, it&rsquo;s done by an external library.
SQLAlchemy is a layer on top of modules like <code>sqlite3</code> that understand how to directly interact with databases.
Under the hood, SQLAlchemy extracts a file path from the database URL and hands that file path to the underlying database module.
This structure, though, eliminates the possibility of asking SQLite to open a <code>file://</code> URI!
It can only send file paths to SQLite, and so the extra capabilities that SQLite activates when it sees the right prompts in a <code>file://</code> URL cannot be activated through SQLite.
SQLAlchemy does try to pass on extra arguments that it finds in the database URL, but it passes those on to underlying database modules like frozen-in-amber-since-2010 <code>sqlite3</code>.<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>
Such extra arguments change the details of <code>sqlite3</code>&rsquo;s behavior, but do not change the way it tries to connect to SQLite.
On older Python versions, <code>pysqlite</code> 2.8.2 or later can be substituted for the built-in <code>sqlite3</code>, but because <code>pysqlite</code> is not available on modern Python versions, this is not a satisfactory solution.</p>

<p>We are in a situation, nearly 10 years after SQLite introduced its connection flags and <code>file://</code> URLs, where taking advantage of those features from Python code is impossible to accomplish with the tools provided by the latest version of Python&rsquo;s best database library, running on the latest version of Python itself.
It&rsquo;s important to note that none of this is malfeasance or incompetence on the part of library or language maintainers.
Projects like the Python language, SQLAlchemy, and SQLite, prize stability very, very highly.
They are <em>infrastructure</em> projects: they want to build durably and to provide durable materials for others to build atop, and they are not wrong in how often they value this above convenience.
The power of defaults is very important here, too: although many OSes ship with Python and/or SQLite built in, those projects in turn have their own release cycles and their own stability concerns.
The first version of <a href="http://robservatory.com/behind-os-xs-modern-face-lies-an-aging-collection-of-unix-tools/">OS X that shipped with a SQLite version</a> able to understand <code>file://</code> URIs was summer 2012&rsquo;s OS X 10.8 &ldquo;Mountain Lion&rdquo; (Summer 2012).
Debian-stable didn&rsquo;t ship with such a SQLite until midway through <code>wheezy</code>&rsquo;s patch sequence (2014).
Ubuntu picked it up faster, incorporating SQLite 3.7.7 in their Oneiric Ocelot release (Fall 2011).
All of these infrastructure projects, reasonably enough, tend to defer building support for any particular thing until they are sure that their users <em>can</em> and <em>want to</em> use it.
Frustratingly, they can unintentionally enable each other in delaying support.
But there is no archfiend actively obstructing the uptake of new versions, just a collection of overworked engineers trying to build things that won&rsquo;t fall apart too easily.</p>

<p>Fortunately, individual programmers writing brand-new projects have no old versions to be bound to.
We can, by investing a little work, make different decisions about stability than project maintainers.
This brings us around to the promise in this post&rsquo;s title.
Python, <code>sqlite3</code>, and SQLAlchemy were all written by clever people with an interest in flexibility.
The tools that they&rsquo;re eager to give us, the defaults, are not the only tools they can give us: there are others.
Let&rsquo;s use those others.</p>

<p>The code below follows a fairly straightforward strategy.
Given a file path and some arguments to pass to SQLite, it begins with some basic plausibility checks.
It ignores the arguments and uses only the path if the caller has an ancient version of SQLite or wants SQLite&rsquo;s <code>:memory:</code> database.
Otherwise, it turns the file path and the arguments into a <code>file://</code> URL, then tries to connect to that URL.
First it tries in the way that Python 3.4+ allows, with a <code>uri=True</code> parameter.
If trying to connect that way is met with &ldquo;I know no such parameter as <code>uri</code>&rdquo;, we know we&rsquo;re on an earlier version of Python.
But since we know that SQLite and <code>sqlite3</code> are available, we use <code>ctypes</code> to reach into the Python/C communication channel that the <code>sqlite3</code> library has already set up.
We prod the variable in C code that tells SQLite we&rsquo;re opting into our input being treated as a URL, then connect again with our URL.
Finally, we create a SQLAlchemy engine.
We tell it that we&rsquo;re connecting to an empty URL<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>, but we also tell it &ldquo;when you go to connect to that URL, use this object we&rsquo;re handing you in order to establish that connection.&rdquo;
The object we hand it is the SQLite connection we just established, which SQLAlchemy doesn&rsquo;t know how to create by itself.</p>

<p>This strategy has some limitations: it definitely won&rsquo;t work as-is on PyPy or Jython, and it&rsquo;s superfluous if you know your project will run only on Python 3.4+.
However, if you want your project to run on multiple versions of Python and to have access to nice SQLite features on all of them, this function will, I hope, get you to that point.
I should also note that I drew inspiration from <a href="https://github.com/pudo/dataset/issues/136">this GitHub issue</a> and <a href="https://gist.github.com/achimnol/3021995">this Gist</a>: the digging is all me, however, as is the unit test.
I&rsquo;m firmly of the opinion that if you tell someone you have code that can solve their problem, the code you provide should be tested.</p>

<p><noscript><pre>import os.path
import re
import sqlite3
from sqlalchemy import create_engine

def create_sqlite_engine(sqlite_path,
                         read_only=None, create_db=None, **kwargs):
    &quot;&quot;&quot;
    Open SQLite with appropriate use of connection flags.

    This is harder than it sounds.
    &quot;&quot;&quot;
    # Requirements: sqlite_path must be either &#39;:memory:&#39; or the output of
    # os.path.abspath(). In this context, the SQLitePathType class handles that
    # for us.
    log.info(&quot;Trying to connect to SQLite ({!r})&quot;.format(sqlite_path))

    sqlite_prefix = &#39;sqlite:///&#39;

    # For an in-memory DB, ignore the flags
    if sqlite_path == &#39;:memory:&#39;:
        log.info(&quot;Fallback: :memory: DB.&quot;)
        return sqlalchemy.engine.create_engine(sqlite_prefix)

    # For atrociously old versions of SQLite, ignore the flags
    if (sqlite3.sqlite_version_info &lt; (3, 7, 7)):
        log.warning((&quot;Found old SQLite version: &quot;
                     &quot;using it, but have to ignore {!r}&quot;).format(kwargs))
        return sqlalchemy.engine.create_engine(sqlite_prefix + sqlite_path)

    kwargs.pop(&#39;mode&#39;, None)
    if create_db:
        kwargs[&#39;mode&#39;] = &#39;rwc&#39;
    else:
        kwargs[&#39;mode&#39;] = &#39;rw&#39;
    # Because the read_only and create_db modes are mutually exclusive, we give
    # priority to the more restrictive mode.
    if read_only:
        kwargs[&#39;mode&#39;] = &#39;ro&#39;

    # Normalize sqlite_path from a platform-bound file path to a
    # platform-agnostic file:// URI (see https://www.sqlite.org/uri.html for
    # details of SQLite&#39;s file:// URI requirements).
    sqlite_path = re.sub(r&#39;\?&#39;, r&#39;%3f&#39;, sqlite_path)
    sqlite_path = re.sub(&#39;#&#39;, r&#39;%23&#39;, sqlite_path)
    drive, sqlite_path = os.path.splitdrive(sqlite_path)

    path_segments = []
    path_head, path_tail = os.path.split(sqlite_path)
    while path_tail != &#39;&#39;:
        path_segments = [path_tail] + path_segments
        path_head, path_tail = os.path.split(path_head)
    if drive != &#39;&#39;:
        path_segments = [drive] + path_segments

    try:
        # Python 3
        query_string = urlparse.urlencode(kwargs)
    except AttributeError:
        # Python 2
        query_string = urllib.urlencode(kwargs)

    file_uri = urlparse.urlunparse(
        (&quot;file&quot;,  # Scheme
         &#39;&#39;,  # Netloc (localhost)
         &#39;/&#39;.join(path_segments),  # Path
         &quot;&quot;,  # Params
         query_string,  # Query
         &quot;&quot;,  # Fragment
         ))

    log.debug(&quot;Database URI: {!r}&quot;.format(file_uri))

    def _sqlite_conn_creator():
        try:
            log.debug(&quot;Trying the easy way...&quot;)
            # In Python 3.4+, we can do this the easy way.
            conn = sqlite3.connect(file_uri, uri=True)
        except TypeError:
            log.debug(&quot;Trying ctypes hackage...&quot;)
            # The ctypes way is not the easy way (nor is it the &quot;compatible
            # with anything but CPython&quot; way).
            import ctypes
            import ctypes.util
            sqlite = ctypes.CDLL(ctypes.util.find_library(&#39;sqlite3&#39;))

            # https://www.sqlite.org/c3ref/c_config_covering_index_scan.html
            SQLITE_CONFIG_URI = 17
            sqlite.sqlite3_config(SQLITE_CONFIG_URI, 1)
            conn = sqlite3.connect(file_uri)

        return conn

    # Dust our hands off, give the caller what they asked for, pretend we
    # didn&#39;t do anything disreputable just now.
    return sqlalchemy.engine.create_engine(sqlite_prefix,
                                           creator=_sqlite_conn_creator)
</pre></noscript><script src="https://gist.github.com/brighid/42ed997016973e16bd04df22bfd638f7.js"> </script></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>URIs, if you&rsquo;re picky.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Specifically, you&rsquo;ll get a <code>sqlite3.OperationalError</code> that signifies a C-level <code>SQLITE_CANTOPEN</code> return code.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>To be fair, Python <em>can&rsquo;t</em> (and <strong>shouldn&rsquo;t!</strong>) compile SQLite for you.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Mostly by switching from <code>sqlite3_open()</code> to <code>sqlite3_open_v2()</code>.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Also by switching from <code>sqlite3_open()</code> to <code>sqlite3_open_v2()</code>.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>See <code>sqlalchemy.dialects.pysqlite.SQLiteDialect_pysqlite.create_connect_args()</code> for the implementation.<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p>Normally this gets you connected to the <code>:memory:</code> DB.<a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Traps]]></title>
    <link href="http://stronglyemergent.com//blog/2013/two-traps/"/>
    <updated>2013-07-02T14:25:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/two-traps</id>
    <content type="html"><![CDATA[<p>Joel Spolsky famously opined that you should look for two things when hiring a programmer: <a href="http://www.joelonsoftware.com/articles/GuerrillaInterviewing3.html">Smart, and Gets Things Done</a>.
Now, there are a lot of smart people in the world
(with a nod in the direction of <a href="http://en.wikipedia.org/wiki/Cattell%E2%80%93Horn%E2%80%93Carroll_theory">the fox/hedgehog debate</a>),
and plenty of them spend some time programming.
Even though there are also a great many people who think themselves smarter than they are, there is a thriving body of lore on filtering that demographic out.
So most of the task of evaluating programmers is about evaluating how and if they Get Things Done.</p>

<p>Evaluating yourself this way is a good skill to have;
lately I&rsquo;ve been trying to build more and tinker more on account of being less-than-fully satisfied with what I see in my self-evaluation.
I&rsquo;ve also noticed two failure modes that smart programmers may fall into
(one of which I&rsquo;m doing my darndest to avoid),
running parallel to the symbols-versus-understanding sides of the <a href="http://en.wikipedia.org/wiki/Chinese_room">Chinese Room Argument</a>.
The argument, oversimplified, is about whether or not it&rsquo;s possible to infer that an unseen conversational partner who manipulates symbols correctly,
<em>understands</em> the communication.</p>

<p>A self-taught programmer is proficient in manipulating symbols, but is vulnerable to the failure mode of not <em>understanding</em> them,
of having a <a href="http://me.veekun.com/blog/2011/04/16/architectural-fallacies/#the-xy-problem">myopia about methods and goals</a>.
On the other hand, engineers who&rsquo;ve been involved in trying to hire from university computer science departments
can attest that CS shops produce a certain proportion of people who understand why all of those symbol-manipulation rules are what they are,
and who know a great deal about the rules and how they are implemented,
but who are curiously unable to actually perform the manipulation of symbols and the latching-together of symbols into structures&mdash;
no GitHub account, no projects of their own, no open-source contributions.</p>

<p>I&rsquo;m nothing like the first person to notice these failure modes, but I think that identifying them as such
(<em>not</em> as &ldquo;all self-taught programmers are flaky&rdquo; or &ldquo;a CS degree is superfluous&rdquo;) is helpful.
Identifying a problem opens up the possibility of solving it.
For me, it was humbling to stumble on the Chinese Room Argument and realize that while I&rsquo;m good at manipulating the symbols,
that is not the same as fluency and I have a lot of work to do ahead of me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Negative 100 Points]]></title>
    <link href="http://stronglyemergent.com//blog/2013/negative-100-points/"/>
    <updated>2013-06-28T20:07:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/negative-100-points</id>
    <content type="html"><![CDATA[<p>A <a href="http://blogs.msdn.com/b/ericgu/archive/2004/01/12/57985.aspx">short post by Eric Gunnerson</a> about designing C#, nearly a decade old now, has stuck with me for a long time.</p>

<blockquote><p>[the question] implies that we started with an existing language (C++ and Java are the popular choices here),
and then started removing features until we got to a point where we liked.
That&rsquo;s not how the language got designed.
One of the big reasons we didn&rsquo;t do this is that it&rsquo;s really hard to remove complexity when you take a subtractive approach,
as removing a feature in one area may not allow you to revisit low-level design decisions,
nor will it allow you to remove complexity elsewhere, in places where it support the now-removed feature.
We decided on the additive approach instead, and worked hard to keep the complexity down.
One way to do that is through the concept of &ldquo;minus 100 points.&rdquo;
Every feature starts out in the hole by 100 points,
which means that it has to have a significant net positive effect on the overall package for it to make it into the language.
Some features are okay features for a language to have, they just aren&rsquo;t quite good enough to make it into the language.</p></blockquote>

<p>If this sounds familiar, it should:
this is another lens on the design philosophy, popularized in the developer community by Apple, that good design requires saying &ldquo;no.&rdquo;
Saying &ldquo;no&rdquo; a <em>lot.</em>
I applaud Apple for applying this philosophy so rigorously&mdash;
but it&rsquo;s important to remember that they&rsquo;re <a href="http://technet.microsoft.com/en-us/magazine/dn167709.aspx">not the only people who use it</a>, and their way is not the only way.
What you say &ldquo;no&rdquo; to, defines you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Prisoner Of Zend.php]]></title>
    <link href="http://stronglyemergent.com//blog/2013/the-prisoner-of-zend-dot-php/"/>
    <updated>2013-06-18T23:30:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/the-prisoner-of-zend-dot-php</id>
    <content type="html"><![CDATA[<p>It is surely not news to you that PHP is awful: there is a thriving sub-genre of tech blog posts about how very, very bad PHP is.
It should tell you something about what a horrid clown rodeo PHP is that even in the presence of Eevee&rsquo;s magisterial &ldquo;<a href="http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/">PHP: A Fractal Of Bad Design</a>&rdquo; article, so many of us feel compelled to contribute to the vast body of PHP-criticizing literature anyhow.
For my part, even after acknowledging excellent works (written by pals smarter than me) like <em>Fractal Of Bad Design</em>, man-of-mystery Pi&rsquo;s &ldquo;<a href="http://two-pi-r.livejournal.com/622760.html?format=light">PHP is a low-level programming language at the wrong level</a>,&rdquo; and Watts Martin&rsquo;s trenchant &ldquo;<a href="http://tracks.ranea.org/post/13908062333/php-is-not-an-acceptable-cobol">PHP is not an acceptable COBOL</a>,&rdquo; I still think there&rsquo;s more that needs saying.
There are plenty of languages that one may dislike, and there are plenty of warts on any language one does like â and yet, PHP is <em>sui generis</em> in its terribleness.</p>

<p>Before starting in on my own complaints, I&rsquo;m going to cite a rant from outside the programming world.
During Leonard Pierce&rsquo;s <a href="http://ludickid.livejournal.com/914741.html?format=light">massively acerbic chronicle of hating Billy Joel</a> there is an aside that I&rsquo;m gonna use to answer the question
&ldquo;why do people hate PHP in a way that people almost never hate JavaScript, C++, or Visual Basic, deeply flawed languages all?&rdquo;</p>

<blockquote><p>Just as one can argue that there were better World Series teams than the 1927 New York Yankees,
one can argue that various performers have written worse songs than those produced from the depressingly fertile mind of Billy Joel.
[&hellip;]
But while there are those who can honestly contend that the &lsquo;27 Bronx Bombers were not the greatest of all World Series teams, no one â
not even those who hate the Yankees with a soul-scorching fire, as do all right-thinking humans â
can argue that they are not the best baseball franchise ever.
The numbers simply speak for themselves.
No other team has even remotely come close to topping their total number of world championships.
Similarly, no other performer or group has ever had so many horrible songs become so successful on the charts as has Billy Joel.
<strong>Others have been worse; others have been bigger.
But no one has been bigger and badder at the same time than Billy Joel.</strong></p></blockquote>

<p>No one has been bigger and badder at the same time than PHP.
That&rsquo;s why.</p>

<p>To expand lightly on the criteria <em>Fractal</em> uses, <strong>a programming language is a tool for thinking about a problem space and for expressing solutions to particular problems in that space.</strong>
The writeups that I&rsquo;ve cited do great work on talking about this, but I think there&rsquo;s a little more that needs to be said.
We usually take this for granted, but a tool for task X should, as the very least, most basic requirement, help you accomplish X more often than it hinders you in trying to accomplish X.
PHP fails at this.
Additionally, software engineering does not happen in a vacuum.
Choices we engineers make affect others, including our future selves.
Software inherently has a social context, and how it interacts with that context, matters (this is where I think <a href="http://www.codinghorror.com/blog/2008/05/php-sucks-but-it-doesnt-matter.html">Jeff Atwood deeply misjudged PHP</a>).
So here&rsquo;s what I want to add to the conversation:</p>

<ul>
<li>PHP is not just a sub-optimal or distasteful tool, it&rsquo;s a <strong>treacherous</strong> one</li>
<li>In addition to being treacherous for those writing it, PHP <strong>pollutes the commons</strong></li>
<li>Because PHP is a treacherous tool whose use pollutes the commons, it <strong>should be torn out and demolished</strong> like an unsafe bridge or building</li>
</ul>


<h3>A Tool That Fits No Hand</h3>

<!-- A treacherous tool -->


<p>Part of why &ldquo;Fractal Of Bad Design&rdquo; commands attention is the sheer volume of issues with PHP it collects and contextualizes.
The gotchas, pitfalls, and boilerplate-chunks in PHP combine to produce an environment where simple, easy-to-read code is often <em>wrong</em>.
In turn, this means that code written with diligence and caution in PHP, is harder to give a close reading to.
You don&rsquo;t need to intensely scrutinize code every time you read it, but when you pick up your own code that you haven&rsquo;t worked with for a while, when you&rsquo;re reviewing code in a security-focused state of mind, or when you&rsquo;re deciding whether external changes require altering the code in front of you, giving the code a close reading is extremely important.
But when the simple way is often wrong, a close reading is far harder than it should be.
You will ask yourself many questions, individually small and not particularly difficult, but enormous in number and potential consequences.</p>

<ul>
<li>Which specific major, minor, and patch version of PHP was this file written against?</li>
<li>Does this function require a particular <code>ini_set()</code> invocation that could be clobbered elsewhere?</li>
<li>Does this if-block behave correctly when the result of an expression is <code>0</code> instead of <code>FALSE</code>?</li>
<li>Does all the code use <code>===</code> instead of <code>==</code>?</li>
<li>Does this function behave acceptably if one of its variables gets clobbered by a global?</li>
<li>Does this block handle <code>sleep()</code>&rsquo;s <a href="http://php.net/manual/en/function.sleep.php#refsect1-function.sleep-returnvalues">many possible return values</a> correctly?</li>
<li>Does this library <a href="http://software-gunslinger.tumblr.com/post/47131406821/php-is-meant-to-die">perpetrate asynchronous atrocities</a> behind my back?</li>
</ul>


<p>The burden of dealing with these questions means that PHP does not just make it possible write bad code, but that its quirks actively make it <em>harder to write good code</em> and more likely that you will write bad code.
You <em>can</em> write good code in PHP, but the path is a fearful one.
Compared to other languages, you will write more lines code to do the same tasks, it&rsquo;s harder to know or prove that the code you&rsquo;ve written is good, and the language ecosystem is so burdened with dubious code that good code cannot be quickly brought into projects of any significant age.
One of Perl&rsquo;s design goals is to &ldquo;make easy things easy and hard things possible.&rdquo;
PHP, as though coming from a mirror universe with a sinister goatee,
<a href="http://phpsadness.com/sad/52">makes easy things hard</a> and <a href="http://software-gunslinger.tumblr.com/post/48215406921/php-is-meant-to-die-continued">hard things impossible</a>.
In a total inversion of good language design, a concise and readable piece of PHP is more likely to have bugs, not less.
This is what pushes PHP from &ldquo;a tool that I have distaste for&rdquo; to &ldquo;a tool that is <strong>bad</strong>&rdquo; â when I say that it is &ldquo;treacherous,&rdquo; I&rsquo;m talking about this property where simple code is prone not just to being wrong, but to being wrong in a way that tends to <a href="https://phpmanualmasterpieces.tumblr.com/post/66426423275/">fail silently</a> and to fail with <a href="https://bugs.php.net/bug.php?id=55439">extremely dangerous effects</a>.</p>

<p>We have a specific term for &ldquo;past technical decisions are making it harder to make the right technical decisions in the present&rdquo;: <a href="http://c2.com/cgi/wiki?TechnicalDebt">technical debt</a>.
Languages change over time.
Production environments often achieve stability specifically by slowing down their update cycle.
This much is normal.
However, the volume of PHP&rsquo;s technical debt makes updates much more of a problem for PHP than in the general case.
Because something like Python&rsquo;s <code>virtualenv</code> or Ruby&rsquo;s <code>rbenv</code> <a href="http://stackoverflow.com/questions/7182176/does-php-have-an-equivalent-to-pythons-virtualenv-or-rubys-sandbox">doesn&rsquo;t exist in the PHP world as of 2013</a>, incremental updates (either of PHP itself or of any library or C module you may happen to be using) are very difficult: the difficulty of using new versions of PHP is dominated by the most out-of-date libraries or language features a project uses.
Because of how hard it is to make them incremental, updates are risky: it is extremely difficult to fully understand and accurately predict their effects, especially in judging security and stability issues.
One of the ways that PHP fails as a tool is that when improvements in the language or in libraries come along, it makes it hard to take advantage of those improvements.</p>

<p>When the question of PHP&rsquo;s quality comes up, inevitably someone tries to use Wikipedia, Facebook, and WordPress as examples of PHP&rsquo;s success.
Even if you leave aside how that&rsquo;s like saying that most American universities are Harvard, it ignores that Wikipedia, Facebook, and WordPress all have significant problems that are directly attributable to their decision to use PHP!
If you are not prepared to deal with those problems, then you had better not use PHP.
To argue that PHP is a good tool because these large, successful projects have been built with PHP while ignoring that all of these projects had to make extraordinary investments in technical infrastructure, is to advocate that other people waste tremendous quantities of time and money.
More precisely, the fact that Wikipedia, Facebook, and WordPress all used PHP is <em>insufficient</em> to demonstrate that you personally should use PHP for anything: you must know how those projects work and what tradeoffs they made in order to to know whether their use of PHP means it&rsquo;s a good idea to use PHP for your application.</p>

<!-- Spoilers: It's not. -->


<p>Wikipedia is the easiest example to pick on here, because they provide all the evidence themselves.
Go and check out a copy of the MediaWiki source code (I&rsquo;m going to treat &ldquo;Wikipedia&rdquo; and &ldquo;MediaWiki&rdquo; as synonymous) and take a look at it.
Reflect on how many engineer-hours it took to get the project to that state, and how many more hours are being requested.
Reflect on the contents of their <a href="http://www.mediawiki.org/wiki/Annoying_large_bugs">&ldquo;Annoying Large Bugs&rdquo;</a> and <a href="https://www.mediawiki.org/wiki/Annoying_little_bugs">&ldquo;Annoying Little Bugs&rdquo;</a> pages.
If you want to use Wikipedia as a role model, being blind to Wikipedia&rsquo;s flaws is a terrible idea.</p>

<p>Because Wikipedia is such a high-profile target (huge PageRank points, huge repository of user-generated content, huge mindshare) there&rsquo;s a <a href="http://www.cvedetails.com/vendor/2360/Mediawiki.html">steady record of vulnerabilities</a> with MediaWiki.
If you get into the plumbing of Wikipedia, get under the layer that just presents pages to visitors, get familiar with the greasy-handed wiki-gnomes, you&rsquo;ll find all kinds of interesting infrastructure designed to cope with this.
As a social project, Wikipedia is not a bad project: it&rsquo;s an amazingly good one.
It&rsquo;s a triumph of the cooperative open-source ethos and an incalculably valuable community resource.
But as an engineering project, you should be very careful about emulating it.
You should make sure that you can invest proportionate engineer-hours into security and maintenance â and that you account for how a PHP-based project needs far more of those hours than other kinds of project.</p>

<p>Speaking of gigantic quantities of engineer-hours, there&rsquo;s Facebook.
Facebook is an even worse choice as an example of PHP&rsquo;s success, because Facebook has effectively re-built PHP from the ground up.
Look at their <a href="https://github.com/facebook/hiphop-php">HipHop PHP</a> project: it&rsquo;s replacing the default PHP interpreter wholesale and replacing Apache&rsquo;s <code>mod_php</code> as well.
You shouldn&rsquo;t use Facebook as evidence that your project should use PHP, because the way you use PHP is not like the way that Facebook uses PHP.
Facebook ended up writing not just their own PHP toolchain, but their own entire PHP runtime.
This is probably not the way you want to go for your project: it&rsquo;s expensive and optimizes for solving problems that you don&rsquo;t have.</p>

<p>On top of that, there are ways in which Facebook&rsquo;s usage of PHP is dubious, or at least suggests that they would rather not be using PHP.
Before the current version of HipHop, which is a VM that executes PHP, they were cross-compiling to C++.
When &ldquo;cross-compile to C++&rdquo; makes your project <em>less</em> painful, that&rsquo;s a bad sign.
This emphasizes the earlier point about technical debt: Facebook at this point is trapped in PHP and making the best of it.
They&rsquo;re up to the point where they&rsquo;re custom-compiling PHP and doing static-analysis optimization on it â which is to say, they are doing <a href="http://www.research.ibm.com/trl/people/mich/pub/200901_popl2009phpsem.pdf">original compsci research</a>, because PHP&rsquo;s internals are that much of a mess.</p>

<p>Nor is WordPress a good PHP role model.
It&rsquo;s gotten better over time, but the direction of its evolution is away from &ldquo;blog&rdquo; and towards &ldquo;maximalist content management system,&rdquo; which massively expands the number of things that can go wrong.
WordPress has a huge difference from Wikipedia and Facebook: rather than being a giant application hosted and administered by someone else, WordPress is a PHP application that you can download, install, and investigate for yourself.
They&rsquo;ve invested a lot of effort in making that part easy.
Unfortunately, &ldquo;easy PHP&rdquo; is pretty much always &ldquo;insecure PHP.&rdquo;
So WordPress has a <a href="http://osvdb.org/search?search[vuln_title]=wordpress&amp;search[text_type]=alltext">long track record of nasty vulnerabilities</a>.
It also has a well-earned reputation as a tool spammers love.
Because it&rsquo;s a platform that you can set up yourself with no gatekeeper (compare to Movable Type, professionally hosted WordPress installations, or Blogger instances), it&rsquo;s become the best choice for spammers (who want to programmatically deploy large numbers of WordPress instances).
Then there&rsquo;s the architecture matter: maybe this is just taste, but I find things like <code>rewind_posts()</code> inherently suspect (and there are <a href="http://www.reddit.com/r/lolphp/comments/1etq3n/wordpress_will_automatically_convert_foo_to_foo/">unproven allegations</a> of grotesque features lurking in the codebase).
More substantially, there&rsquo;s mutable global state lurking all over the place (on top of the distressing action-at-a-distance issues PHP inherently has â see Eevee&rsquo;s writeup for more about that), the app buys into <a href="http://www.reddit.com/r/lolphp/comments/1dzvjk/wordpress_core_is_secure_stop_telling_people/c9vlcpi">the &ldquo;sanitize input&rdquo; voodoo</a>, and like most PHP apps, it requires a bunch of read-and-write access to its environment that other language ecosystems .
Wordpress' engineering problems lead to persistent and near-intractable security problems, and those problems affect more than just the people running WordPress blogs.</p>

<h3>The Superfund Site Of Programming Languages</h3>

<!-- Polluting the commons -->


<p>Because of the friction discussed earlier, problems fixed or mitigated in new versions of PHP (tremendous improvements on versions like PHP4) have a very long half-life before they&rsquo;re no longer found in the wild.
Obstacles to upgrading software don&rsquo;t have to be insurmountable to keep users on old versions, they just have to exist.
There&rsquo;s a big difference between &ldquo;easy enough that people <em>can</em> do it&rdquo; and &ldquo;easy enough that people <em>actually</em> do it,&rdquo; and PHP is on the wrong side of that difference.
The design &amp; usability world has known for a long time that if the right thing and the easy thing are different, your users will almost never do the right thing.
PHP&rsquo;s legacy of technical debt means that maintaining PHP code has far too much friction for maintainers to always do the right thing.
I throw the epithet &ldquo;avatar of technical debt&rdquo; at PHP sometimes, because this dynamic means that to use PHP at all is to incur a wallop of technical debt.
Worse, this technical debt is almost always an <a href="http://en.wikipedia.org/wiki/Externality#Negative">externality</a>, a cost that the person writing the code doesn&rsquo;t have to pay.
Instead, <a href="https://phpmanualmasterpieces.tumblr.com/post/78455397098/nothing-is-deprecated-everything-is-permitted">the cost is borne by unknown future engineers and users</a>.
Beware of externalities!
If you are not paying the real, full costs of your decisions, <a href="http://en.wikipedia.org/wiki/Moral_hazard">you will be led to make worse decisions</a>.
Because PHP fails so hugely at making the right thing easy, it tends to make the wrong thing the default â and the costs of dealing with the wrong thing are all too often externalized, whether that&rsquo;s from today&rsquo;s coder to the same person tomorrow, from an engineer to a sysadmin, or from the vendor to the users of a piece of software.</p>

<p>That it&rsquo;s hard to update PHP projects wouldn&rsquo;t matter if those projects were only relevant to their creators and users.
This is not the case: those projects are relevant to the public good.
As programmers, do not create, modify, or use software in isolation.
We interact with software in a social context, in a technological context, and in a networked context.
Similar to how herd immunity in medicine means that the chance of catching a particular disease is unevenly distributed, software vulnerabilities are dangerous even to people who aren&rsquo;t running the affected software.
The most common thing that an attacker might do with a compromised machine is suborn its resources, using it to propagate further attacks (e.g. having it join a botnet).
This is why it matters that PHP is so big and so bad: even if I don&rsquo;t write any PHP code and don&rsquo;t operate anything based on PHP (or on MySQL, its <a href="http://grimoire.ca/mysql/choose-something-else">co-conspirator in suckitude</a>), PHP is still a severe and frequent problem for me!</p>

<p>In the recent past:</p>

<ul>
<li>A security researcher finds that of sites vulnerable to password dumps, <a href="http://blog.passwordresearch.com/2013/02/passwords-found-in-wild-for-january-2013.html">most are built on PHP</a>.</li>
<li>A remote-code-execution vulnerability in two of the most popular WordPress plugins is discovered â and the subsequent patches have an <a href="http://hackertarget.com/running-wordpress-patch-your-plugins/">utterly dismal uptake rate</a>.</li>
<li>There are a multitude of PHP-based server control panels that have deeply <a href="http://seclists.org/fulldisclosure/2013/Apr/139">disturbing security problems</a> of <a href="http://www.reddit.com/r/programming/comments/1gfve8/how_not_to_handle_a_critical_security/">grave severity</a>.</li>
<li>A search on GitHub reveals a multitude of PHP projects open to a <a href="https://github.com/search?p=1&amp;q=extension%3Aphp+mysql_query+%24_GET&amp;ref=searchresults&amp;type=Code">trivial SQL injection</a> attack.</li>
<li>A bug in parsing URLs â surely an action that should be a core competency for a &ldquo;web language&rdquo;! â turns out to be <a href="https://www.idontplaydarts.com/2013/06/http-parameter-pollution-with-cookies-in-php/">implemented in the shoddiest way</a>.</li>
</ul>


<p>Returning to WordPress in particular, WordPress' popularity exacerbates these security problems: WordPress has become a platform as much as it is an app.
Going from app to platform is both difficult in general and difficult particularly in the security context.
A WordPress setup&rsquo;s susceptibility to attack comes not just from problems in code its users write nor just from problems in code that WordPress' creators write, but by those potential problems multiplied by <a href="http://thedailywtf.com/Articles/Pot-o-Gold.aspx">the worst code</a> in any plugin or theme being used.
There are a huge number of WordPress themes and plugins, and they can do anything they like.
For example, there&rsquo;s <a href="http://wordpress.org/plugins/repress/">RePress</a>, which staples a web proxy onto the side of your blog for the use of folks in locales where services like Google and Wikipedia are blocked.
Whatever one thinks of RePress, it&rsquo;s only possible for it to exist because WordPress just picks up plugin code and lets it do whatever it asks.
WordPress is a particularly acute example because its target audience is non-engineering users.
Someone who sets up an instance of MediaWiki, Joomla, or Drupal faces a higher barrier to entry than a WordPress user, who is the beneficiary of vigorous and successful efforts to make WordPress accessible to a wide audience.
Unfortunately, that experience of easy-to-install software ends up re-enacting the Windows 9x era: it&rsquo;s very easy to install things that create opportunities for attackers, and almost impossible to tell ahead of time which things are safe to install.
In WordPress' case, some of its most high-profile plugins, like the <a href="http://www.hyphenet.com/blog/2013/02/01/hackers-still-scanning-for-vulnerable-timthumb-scripts/">TimThumb image resizer</a> and the popular caching plugins, have seen remote-code-execution vulnerabilities that can be exploited at scale, by botnets â and which are particularly likely to succeed against users of WordPress whose blogs and their upkeep are not an every-waking-moment concern.</p>

<p>I worked with <a href="http://seclists.org/fulldisclosure/2009/Feb/255">Magento</a> professionally for a while, and one thing that gave me massive creepy-crawlies about it was that it has the same kind of wild and problematic plugin ecosystem as WordPress, but centered around an app that&rsquo;s meant to be handling people&rsquo;s credit-card information.
&ldquo;All the security of WordPress, also people use it to handle money!&rdquo; does not inspire confidence (though with eBay now running the show, there&rsquo;s a good chance that Magento will have the budget to shape up security-wise).</p>

<p>If the problems I&rsquo;ve been talking about only affected the people actually running that software, I&rsquo;d care far less.
It&rsquo;s important for people have to the right to make their own dang mistakes.
But these things don&rsquo;t happen in a vacuum.
Facebook is the ultimate example: <a href="http://insecure.org/search.html?q=facebook">a steady trickle of facebook vulnerabilities</a> make their way to light over time, and there are over a billion Facebook users who can be very directly affected by them.
Every unpatched MediaWiki install sitting around, every forgotten WordPress instance, every homebrew app quietly chugging away, is susceptible to becoming part of a botnet and worsening the state of the entire Internet.
Every machine that gets rooted, is another machine conducting attacks of one kind or another â and even all of <em>my</em> own servers run on an imaginary free-ponies-with-awesome-sparkles-and-no-security-vulnerabilities-ever language, a legion of zombie PHP-running boxes can still just throw denial-of-service attacks my way until it doesn&rsquo;t matter what I&rsquo;m running.</p>

<p>This is why it <em>matters</em> that PHP is both big and bad: by being both ubiquitous and insecure, it pollutes the commons.
It adds unncessary cost and friction to any project we undertake that&rsquo;s connected to the Internet â which is to say, to everything.
Every server that connects to the Internet has its attack surface artificially enlarged because PHP&rsquo;s own attack surface is so vast.
Programming doesn&rsquo;t happen in a vacuum, it happens in an ecosystem â an ecosystem that PHP-based systems have a long and terrifying track record of dumping nuclear waste into.</p>

<h3>Public Hazard</h3>

<!-- PHP is a public hazard -->


<p>Its being sub-optimal, distateful to me, or outright poorly designed, wouldn&rsquo;t <em>remotely</em> justify my spending time and heartache on telling people not to use PHP.
Likewise, I don&rsquo;t think that PHP will make you a worse programmer except in the extremely boring sense that it&rsquo;ll waste a lot of your time and thus make it harder to rack up the quantities of deliberate-focused-practice time that one needs for mastery, which is absolutely not a sense worth picking a fight over: everyone has a right to their own yak-shaving.
There are plenty of people out there being total jackasses &ldquo;in defense of&rdquo; PHP, but those people are freely deciding to be jackasses: their social deficiencies are very much separate from their choice of programming language (plus, Ruby is an amazing language and its community has no shortage of tremendous jackasses).
As a programmer who cares about craft and tools, I think other languages will reward your time &amp; effort far better than PHP, but if you don&rsquo;t use those, oh well.
I have zero interest in picking a fight over PHP on that basis.
As someone who cares about the Internet being safe and functional enough for me to buy music, check my credit card balance, and communicate with my friends, I want you to stop using PHP and replace existing PHP code â like, <strong>yesterday</strong> â and I think you should be restrained from using PHP for new projects.
I&rsquo;m willing to pick a fight about PHP on the basis of its decade-and-counting track record of design problems that cause security problems that cause &ldquo;you don&rsquo;t write or use PHP but this is going to mess up your day anyhow!&rdquo; problems.</p>

<p><strong>Software can&rsquo;t be isolated from its social context any more than it can be isolated from its technological context.</strong>
The social and technological context of modern software is the Internet.
With a large enough userbase, any software project is <em>de facto</em> infrastructure (especially if it participates in the Internet).
As builders of infrastructure, we have a moral responsibility to not build hazardous, shoddy infrastructure because doing so hurts everyone who uses or depends on that infrastructure, even indirectly.
PHP&rsquo;s track record demonstrates that it is a grossly deficient tool for building infrastructure.
When you undertake to build or maintain infrastructure, you take on a responsibility to everyone affected by the quality &amp; functionality of that infrastructure.
Choosing to use grossly deficient tools like PHP is irresponsible and unethical for builders of infrastructure, especially if it&rsquo;s justified in terms of ease or of being able to build a thing swiftly.
By definition, infrastructure projects require that you prioritize durability and certainty over ease and swiftness!
Nor is there an argument to be had on a &ldquo;the other tools are also flawed&rdquo; basis: none of the other tools have PHP&rsquo;s decade-long track record of massive deficiency, nor do their maintainers have the indifference towards fixing deficiencies that PHP&rsquo;s maintainers display.
It is only by combining its track record of problems with the long reach that those problems have, that PHP crosses the threshold of &ldquo;should people be restrained from using this tool?&rdquo;
No-one should lower the requirements for that kind of thing: we should be very, very wary of doing so.
PHP has met those requirements: there are no other tools in such wide use whose problems are so many, are inflicted on so many people beyond the tool&rsquo;s users, have gone unfixed for so long, have so few virtues to excuse them, and are the responsibility of maintainers who have done so little to fix them.
Nothing short of that should prompt the programming community to say &ldquo;no, this tool is not okay to use, stop.&rdquo;</p>

<p>How to attain the elimination of PHP is a question I don&rsquo;t have a good answer for, and it&rsquo;s obvious that the programming community as a whole hasn&rsquo;t yet come up with a good answer.
It&rsquo;s especially important to demand that a scheme for reducing &amp; eliminating PHP not make it more difficult to get into programming.
PHP offers &ldquo;you can just write code and see it work!&rdquo; and that&rsquo;s a hugely, hugely important feature for making programming accessible â the problem is that PHP offers this feature at a ruinously high cost and smudges the ink on the metaphorical price tag.
I also think it&rsquo;s going to be very difficult in general: I&rsquo;ve been comparing PHP to pollution-causing industrial tactics here, but America has not done at all a good job of holding people who cause pollution responsible for its harmful effects.</p>

<p>I look forward to a future where we&rsquo;ve invested the collective effort in building tools that fit our hands gracefully and that don&rsquo;t sabotage our efforts to build durable, predictable, world-improving infrastructure.
Software has both a social and a technological context: this means that the apparently-social problem of eliminating PHP also is a technical problem.
The technical problem is &ldquo;how do we build something better than PHP?&rdquo; and the tremendous numbers of beautiful &amp; useful solutions we&rsquo;ve already come up with for that problem, give me every confidence that we can handle that part.
Now let&rsquo;s work on the social part.</p>

<p><em>Note: this post was updated in summer 2016.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Date With Ruby]]></title>
    <link href="http://stronglyemergent.com//blog/2013/first-date-with-ruby/"/>
    <updated>2013-06-15T08:57:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/first-date-with-ruby</id>
    <content type="html"><![CDATA[<p>Last night I took a notion into my head and wound up spending a solid few hours with Ruby.
I&rsquo;m happy with how that went! There&rsquo;s some first-time-with-a-new-language friction, but nothing out of the ordinary.
Here&rsquo;s what I came up with, and afterwards, why I chose that and what I think it shows that I accomplished that.</p>

<p><noscript><pre>require &#39;cgi&#39;
require &#39;json&#39;
require &#39;net/http&#39;
require &#39;uri&#39;

module Jekyll
  class MusicLink &lt; Liquid::Tag

    def initialize(tag_name, contents, tokens)
      super
      @contents = contents
    end

    def render(context)
      @affiliateCode = &#39;secret&#39; # Fill in yours!
      page = context.environments.first[&#39;page&#39;]
      if page[&#39;music-artist&#39;] &amp;&amp; page[&#39;music-track&#39;]
        music_url, music_string = getMusic(page[&#39;music-artist&#39;], page[&#39;music-track&#39;])
        return %(&lt;span class=&#39;music-box&#39;&gt;Music: &lt;a class=&#39;music-link&#39; href=&quot;#{music_url}&quot;&gt;#{music_string}&lt;/a&gt;&lt;/span&gt;)
      else
        return %()
      end
    end

    def makeItunesTarget(artist, track)
      iTunesURL = URI(&quot;https://itunes.apple.com/search&quot;)
      iTunesParams = {
        :country =&gt; &quot;us&quot;, :media =&gt; &quot;music&quot;,
        :limit =&gt; &quot;5&quot;, :entity =&gt; &quot;musicTrack&quot;,
        :term =&gt; artist + &quot; &quot; + track,
      }
      iTunesURL.query = URI.encode_www_form(iTunesParams)
      return iTunesURL
    end

    def getFromItunes(iTunesURL)
      http = Net::HTTP.new(iTunesURL.host, iTunesURL.port)
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_PEER

      request = Net::HTTP::Get.new(iTunesURL.request_uri)
      response = http.request(request)
      if response.code == &quot;200&quot;
        jsonResponse = JSON.load(response.body)
        if jsonResponse[&#39;resultCount&#39;] == 0
          jsonResponse = false
        end
      else
        jsonResponse = false
      end
      return jsonResponse
    end

    def makeAnchorFromItunesData(iTunesJSON)
      unless iTunesJSON
        return iTunesJSON, iTunesJSON
      end

      primaryResult = iTunesJSON[&#39;results&#39;].first
      if @affiliateCode
        urlRegex = /(https:\/\/itunes\.apple\.com\/[^?]+\?[^&amp;]+).+/
        urlReplacement = &#39;\1\2&amp;partnerId=30&amp;siteID=&#39; + @affiliateCode
        affiliatedTrackUrl= primaryResult[&#39;trackViewUrl&#39;].sub(urlRegex, urlReplacement)
        primaryResult[&#39;trackViewUrl&#39;] = affiliatedTrackUrl
      end

      anchorURL = primaryResult[&#39;trackViewUrl&#39;]
      anchorString = CGI.escapeHTML(&quot;%s - %s&quot; % [primaryResult[&#39;artistName&#39;], primaryResult[&#39;trackName&#39;]])
      return anchorURL, anchorString
    end

    def getMusic(artist_name, track_name)
      music_url, music_string = makeAnchorFromItunesData(getFromItunes(makeItunesTarget(artist_name, track_name)))
      return music_url, music_string
    end

  end
end

Liquid::Template.register_tag(&#39;music&#39;, Jekyll::MusicLink)
</pre></noscript><script src="https://gist.github.com/brighid/c3d19f2c6749fbec30ed.js?file=itms_music_link.rb"> </script></p>

<p>This creates a new Liquid tag, <code>{% music %}</code>, which can be inserted in page templates.
I added it to my <code>footer.html</code> after the byline, timestamp, and categories.
The tag checks whether the post&rsquo;s YAML front-matter has data for a musician and a track name.
If the post has that data, the plugin attempts to create a link to the iTunes Store for the given track.
With <code>makeItunesTarget()</code> it puts together a URL that is a query to the <a href="http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html">iTunes Store Search API</a>, with <code>getFromItunes()</code> it loads the query URL and hands off the response to the standard library&rsquo;s JSON parser, and with <code>makeAnchorFromItunesData()</code> it takes the first search result and generates text to use for an <code>&lt;a&gt;</code> tag and a URL to use for the tag&rsquo;s <code>href</code> attribute (if you have an affiliate code for the iTunes store, it&rsquo;ll be inserted).
Finally, there&rsquo;s a convenience function, <code>getMusic()</code>, that just composes the previous three.</p>

<p>Part of why this worked well is that it&rsquo;s another project with limited scope: I had a specific objective in mind, so I was able to keep moving gradually towards it.
However, that limited scope was a way of making progress towards the broad goal of &ldquo;learn Ruby&rdquo; and also took on the medium-scope goal of &ldquo;learn the iTunes Store Search API.&rdquo;
As a practical matter, learning to work with other people&rsquo;s APIs, whether they&rsquo;re libraries, services, or daemons, is an important skill for a working programmer; toy projects that include cultivating that skill are good uses of my time.
Learning new languages is also a career-long thing: for all the talk of Lisp being &ldquo;the hundred-year language,&rdquo; no-one now working as a programmer will be programming in just one language for the rest of their days.
There are shell scripts and libraries and wrappers: there is a fragmented world that despite the friction of fragmentation, would not actually be better-served by a language monoculture.
In addition, there are plenty of exciting things out there whose roots are in Ruby, so I was enthusiastic about picking up a smattering of Ruby.</p>

<p>I&rsquo;m definitely fond of Ruby so far.
Part of this is because I&rsquo;m getting to the point where I&rsquo;m seeing parallels with other languages and able to make good guesses about how a new language will behave.
I was able to guess from reading source &ldquo;oh okay, Ruby is one of the languages where the return value of a function, if not explicit, is the value of the last statement evaluated in its body,&rdquo; was pleasantly surprised that it has the same tuple-packing return-multiple-values feature as Python, and noticed &ldquo;oh hey neat, there&rsquo;s a Scheme-like <code>function!()</code> naming convention for functions that mutate their parameters.&rdquo;
So that&rsquo;s all good stuff.</p>

<p>Part of choosing Ruby, too, is that I&rsquo;m currently blogulating via Octopress, which is built on Ruby.
Most of why I chose it is that Wordpress is awful (on the axes I care about), but now that I&rsquo;ve chosen it, I want to have a grasp of how it works.
That means learning Ruby and tinkering&mdash;which I&rsquo;m looking forward to.</p>

<p>As a supplemental note, if this stuff sounds to you like a good attitude for a programmer to have, you should <a href="http://careers.stackoverflow.com/stronglyemergent">hire me</a>.</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: www | Strongly Emergent]]></title>
  <link href="http://stronglyemergent.com//blog/categories/www/atom.xml" rel="self"/>
  <link href="http://stronglyemergent.com//"/>
  <updated>2015-11-28T03:31:05-08:00</updated>
  <id>http://stronglyemergent.com//</id>
  <author>
    <name><![CDATA[Strongly Emergent Systems]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[An Innovative Business Model]]></title>
    <link href="http://stronglyemergent.com//blog/2013/an-innovative-business-model/"/>
    <updated>2013-07-05T20:57:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/an-innovative-business-model</id>
    <content type="html"><![CDATA[<p>Every so often Pantone blows my mind. Their business model is that they <em>sell colors</em>&mdash;not that
they sell paint or ink or dye, no, they sell <em>colors!</em> It&rsquo;s a little unbelievable. Of course if you
venture into the world of printing, publishing, and large-scale content creation in general, color
is just one of many important details that have to not only be right, but right in a way that you
can talk to others sensibly about. So Pantone can be thought of as a standards body like ISO&mdash;and
like ISO, they aren&rsquo;t cheap, and they look rather surreal from the outside.</p>

<p>They&rsquo;re a great lesson in that way, though: sometimes to understand odd things, you have to meet
them on their own terms, not on yours. Otherwise you&rsquo;ll be looking at
<a href="http://www.pantone.com/pages/index.aspx?pg=21055">&ldquo;Emerald is the color of the year!&rdquo;</a> and be staring at your monitor mouthing &ldquo;what the
devil does that mean, who decided that, how the heck is a color &lsquo;lush&rsquo;?&rdquo; But it makes perfect sense
on its own terms. Like many other things in the world, it exists for itself and those who know it,
not for strangers.</p>

<p>Of course, you may want to treat my opinion on the matter with skepticism since I&rsquo;m the kind of
person who finds the <a href="http://www.pantone.com/pages/products/product.aspx?pid=1376&amp;ca=33">Emerald Pantone iPhone Case</a> mildly fetching.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Prisoner Of Zend, Duh]]></title>
    <link href="http://stronglyemergent.com//blog/2013/the-prisoner-of-zend-duh/"/>
    <updated>2013-06-18T23:30:00-07:00</updated>
    <id>http://stronglyemergent.com//blog/2013/the-prisoner-of-zend-duh</id>
    <content type="html"><![CDATA[<p>It is surely not news to you that PHP is awful: there is a thriving sub-genre of tech blog posts
about how very, very bad PHP is. It should tell you something about what a clown rodeo PHP is that
even in the presence of Eevee&rsquo;s magisterial <a href="http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/">&ldquo;PHP: A Fractal Of Bad Design&rdquo;</a> article, so
many of us feel compelled to contribute to the vast body of PHP-criticizing literature anyhow. For
my part, even after acknowledging excellent works like &ldquo;Fractal Of Bad Design,&rdquo; man-of-mystery Pi&rsquo;s
<a href="http://two-pi-r.livejournal.com/622760.html?format=light">&ldquo;PHP is a low-level programming language at the wrong level,&rdquo;</a> and Watts Martin&rsquo;s
pungently-named <a href="http://tracks.ranea.org/post/13908062333/php-is-not-an-acceptable-cobol">&ldquo;PHP is not an acceptable COBOL,&rdquo;</a> all written by pals who are smarter than
I am, I still am called to add to the discourse. There are plenty of languages that one may
dislike, and there are plenty of warts on any language one does like&mdash;and yet, PHP is <em>sui
generis</em> in its terribleness.</p>

<p>Before starting in on my own complaints, I&rsquo;m going to stop and acknowledge another rant: during
Leonard Pierce&rsquo;s delightfully <a href="http://ludickid.livejournal.com/914741.html?format=light">funny and acerbic chronicle of hating Billy Joel</a>, there
is an aside that answers very well the question of why people hate PHP in a way that people almost
never hate JavaScript, C++, or Visual Basic, deeply flawed languages all of them.</p>

<blockquote><p>Just as one can argue that there were better World Series teams than the 1927 New York Yankees,
one can argue that various performers have written worse songs than those produced from the
depressingly fertile mind of Billy Joel. &ldquo;Yummy Yummy Yummy,&rdquo; to cite an older example, is
certainly the product of a nightmarish hatred of all humanity, and arguably worse than any Billy
Joel song. To cite a more recent example, &ldquo;My Humps&rdquo; offends the soul and mind in ways to which
only the most cretinous songs by the Man from Hicksville can aspire. But while there are those
who can honestly contend that the &lsquo;27 Bronx Bombers were not the greatest of all World Series
teams, no one&mdash;not even those who hate the Yankees with a soul-scorching fire, as do all
right-thinking humans&mdash;can argue that they are not the best baseball franchise ever. The numbers
simply speak for themselves. No other team has even remotely come close to topping their total
number of world championships. Similarly, no other performer or group has ever had so many
horrible songs become so successful on the charts as has Billy Joel. <strong>Others have been worse;
others have been bigger. But no one has been bigger and badder at the same time than Billy
Joel.</strong></p></blockquote>

<p>No one has been bigger and badder at the same time than PHP.</p>

<p>The things that make me most unhappy about PHP center around the fact that software development
does not happen in a vacuum. Our choices as developers affect others, including our future
selves. Most of the substance of the writeups that I&rsquo;ve cited is devoted to PHP&rsquo;s legion of
failings as an abstract tool for computation: they&rsquo;ve got that well-covered. What I want to focus
on is PHP&rsquo;s catastrophic badness as a participant in a living ecosystem of software projects,
tools, and traffic (this is where I think <a href="http://www.codinghorror.com/blog/2008/05/php-sucks-but-it-doesnt-matter.html">Jeff Atwood deeply misjudged PHP</a>). There
are three broad areas of failure here:</p>

<ul>
<li>PHP is the avatar of technical debt</li>
<li>The flagship PHP projects are bad examples</li>
<li>PHP&rsquo;s flaws grievously pollute the commons</li>
</ul>


<p>In all three of these areas, my beef is the effects that PHP-the-language and PHP projects have on
the world around them. The ways in which PHP is broken as a tool for computation, lead directly to
the ways in which the software written in PHP is broken as a tool for improving people&rsquo;s lives.</p>

<h3>The Avatar Of Technical Debt</h3>

<p>One of the most visible ripple effects of PHP is the effect is has on maintenance programmers and
on &ldquo;consumers&rdquo; of code. Even stipulating that the newest versions of PHP are tremendous
improvements on PHP4, legacy code is still a thing in general, and PHP&rsquo;s specific shape makes it
more of a problem for PHP than in the general case. Because of the tremendous obstacles to setting
up something like Python&rsquo;s <code>virtualenv</code> or Ruby&rsquo;s <code>rbenv</code> in the PHP world, the uptake of new
versions of PHP is disproportionately impaired by the most out-of-date libraries or language
features being used. &ldquo;Past technical decisions making it harder to make the right technical
decisions in the present&rdquo; is pretty much the definition of <a href="http://c2.com/cgi/wiki?TechnicalDebt">technical debt</a>.</p>

<p>The obstacles don&rsquo;t have to be insurmountable to keep people from upgrading. It just has to have
friction somewhere in the process. The difference between &ldquo;easy enough that people can do it&rdquo; and
&ldquo;easy enough that people <em>do</em> do it,&rdquo; is significant. PHP is on the wrong side of that difference:
breaking changes have been introduced in minor versions, for example. And the bigger the PHP
codebase you&rsquo;re maintaining, the slower your upgrades will be, because you have a ton of surface
area to deal with and you can&rsquo;t use something like <code>virtualenv</code> or <code>rbenv</code> to attempt an
incremental update of either PHP itself or of any library or C module you may happen to be
using. The cost of upgrading rises faster than with other languages because of this: you have fewer
ways to escape dependency traps.</p>

<p>On top of this, PHP has enough gotchas, pitfalls, and required boilerplate that reading it
carefully is difficult. You don&rsquo;t need to read code like this all the time, but there are times
when you absolutely will need to read code like this&mdash;the most benign example is when you pick up
your own code that you haven&rsquo;t worked with for a while, but you&rsquo;ll also read code this way when
you&rsquo;re reviewing it in an appsec-centric state of mind. PHP makes this task harder, and so
artificially increases the amount of technical debt you take on, whether you&rsquo;re working with your
own code or others'. Which version of PHP was this file written against? Does this function require
a particular <code>ini_set()</code> invocation that could be clobbered elsewhere? Does this if-block behave
correctly when the result of an expression is <code>0</code> instead of <code>FALSE</code>? Does all the code use <code>===</code>
instead of <code>==</code>? Does this function behave acceptably if one of its variables gets clobbered by a
global?</p>

<p>Maintaining PHP code has too much friction for people to do so diligently in practice. This is why
the &ldquo;you can write FORTRAN in any language&rdquo; rebuttal to criticisms of PHP is so utterly bankrupt:
PHP does not just make it <em>possible</em> to write bad code, its quirks actively make it harder to write
good code.  One of Perl&rsquo;s slogans is that the language &ldquo;makes easy things easy and hard things
possible.&rdquo; PHP, as though coming from a mirror universe with a sinister goatee, makes easy things
hard (behold the <a href="http://phpsadness.com/sad/52">absolute train wreck</a> of PHP&rsquo;s comparison operators) and
<a href="http://software-gunslinger.tumblr.com/post/48215406921/php-is-meant-to-die-continued">hard things impossible</a> (largely because <a href="http://software-gunslinger.tumblr.com/post/47131406821/php-is-meant-to-die">PHP is meant to die</a>). In a
perversion of good language design, a concise and readable piece of PHP is <em>more</em> likely to have
bugs, not less. I call PHP the avatar of technical debt because using PHP at all is incurring
tremendous technical debt that comes from this friction with libraries and ensuring good code. You
can write good code in PHP&mdash;but it&rsquo;s harder to <em>know</em> that you&rsquo;ve written good code, the good code
will be longer, and the cost of updating the language and libraries makes it harder to get good
code into production.</p>

<p>Critically, this technical debt is almost always an <a href="http://en.wikipedia.org/wiki/Externality#Negative">externality</a>: it is a cost
that the person writing the code doesn&rsquo;t have to pay. Instead, the cost is borne by future
engineers and users who might as well be strangers. Beware of externalities! If you are not paying
the real, full costs of your decisions, <a href="http://en.wikipedia.org/wiki/Moral_hazard">you will be led to make bad decisions</a>.
Because PHP fails to make the right thing easy, it tends to make the wrong thing the default&mdash;and
the costs of dealing with the wrong thing are all too often externalized, whether that&rsquo;s from a
coder to their future self, from an engineer to a sysadmin, or from a vendor to the users of
software.</p>

<h3>Don&rsquo;t Follow The Leader</h3>

<p>When the question of PHP&rsquo;s awfulness comes up, inevitably someone tries to use Wikipedia, Facebook,
and WordPress as examples of PHP&rsquo;s success. Even if you leave aside how that&rsquo;s like saying that
Harvard is an average American university, Wikipedia, Facebook, and WordPress all have significant
problems that are directly attributable to their decision to use PHP! If you are not prepared to
deal with those problems, then you had better not use PHP. The fact that Wikipedia, Facebook, and
WordPress are all built on PHP is <em>insufficient</em> to demonstrate that you personally should use PHP
for anything: you have to know more about how those projects work and the tradeoffs they made, to
know if their use of PHP recommends PHP for your application.</p>

<!-- Spoilers: It doesn't. -->


<p>Wikipedia is the easiest example to pick on here, because they provide all the damning evidence
themselves. Go and check out a copy of the MediaWiki source code (I&rsquo;m going to treat &ldquo;Wikipedia&rdquo;
and &ldquo;MediaWiki&rdquo; as mostly synonymous here) and take a look at it. Reflect on how many
engineer-hours it took to get the project to that state, and how many more hours are being
requested. Reflect on the contents of their <a href="http://www.mediawiki.org/wiki/Annoying_large_bugs">&ldquo;Annoying Large Bugs&rdquo;</a> and
<a href="https://www.mediawiki.org/wiki/Annoying_little_bugs">&ldquo;Annoying Little Bugs&rdquo;</a> pages. If you want to use Wikipedia as a role model, being
blind to Wikipedia&rsquo;s flaws is a terrible idea.</p>

<p>Because Wikipedia is such a high-profile target (huge PageRank points, huge repository of
user-generated content, huge mindshare) there&rsquo;s a <a href="http://www.cvedetails.com/vendor/2360/Mediawiki.html">steady record of vulnerabilities</a>
with MediaWiki. If you get into the plumbing of Wikipedia, get under the layer that just presents
pages to visitors, get familiar with the greasy-handed wiki-gnomes, you&rsquo;ll find all kinds of
interesting infrastructure designed to cope with this. I wouldn&rsquo;t like to see anyone argue that
Wikipedia is a bad project. It&rsquo;s a triumph of the open-source ethos, and an incalculably valuable
community resource for the entire Internet-using population. But as an engineering project, you
should be very careful about emulating it. You should make sure that you can invest proportionate
engineer-hours into security and maintenance&mdash;and that you account for how a PHP-based project
needs more of those hours.</p>

<p>Speaking of gigantic quantities of engineer-hours, there&rsquo;s Facebook. Facebook is an even worse
choice as an example of PHP&rsquo;s success, because Facebook has effectively forked PHP. Look at their
<a href="https://github.com/facebook/hiphop-php">HipHop PHP</a> project: it&rsquo;s replacing the default PHP interpreter wholesale, and
replacing Apache/<code>mod_php</code> as well. You shouldn&rsquo;t use Facebook as evidence that your project should
use PHP, because the way you use PHP is not like the way that Facebook uses PHP. Facebook basically
ended up writing their own entire PHP toolchain! This is probably not the way you want to go for
your project.</p>

<p>On top of that, there are ways in which Facebook&rsquo;s usage of PHP is dubious, or at least suggests
that they would rather not be using PHP. Before the current version of HipHop, which is a VM that
executes PHP, they were cross-compiling to C++. When &ldquo;cross-compile to C++&rdquo; makes your project less
painful, that&rsquo;s a bad sign. This loops back to the &ldquo;avatar of technical debt&rdquo; thing. Facebook at
this point is <em>trapped</em> in PHP and making the best of it: they have a bigger PHP codebase to
maintain, so they&rsquo;re more trapped. They&rsquo;re up to the point where they&rsquo;re compiling PHP and doing
static-analysis optimization on it&mdash;which is to say, they are doing
<a href="http://www.research.ibm.com/trl/people/mich/pub/200901_popl2009phpsem.pdf">original computer-science research</a>, because PHP&rsquo;s internals are that much of a
mess.</p>

<p>WordPress is also not a good PHP role model: it&rsquo;s gotten better over time, but the direction of its
evolution is away from &ldquo;blog&rdquo; and towards &ldquo;maximalist content management system,&rdquo; which means
expanding the attack surface. WordPress is actually less of a bad PHP role model than Wikipedia and
Facebook: rather than being a giant application hosted and administered by Someone Else, WordPress
is a PHP application that you can download, install, and investigate for yourself. They&rsquo;ve invested
a lot of effort in making that part easy.</p>

<p>Unfortunately, &ldquo;easy PHP&rdquo; is pretty much always &ldquo;insecure PHP.&rdquo; So WordPress has a
<a href="http://osvdb.org/search?search[vuln_title]=wordpress&amp;search[text_type]=alltext">long track record of nasty vulnerabilities</a>. It&rsquo;s also saddled with a
reputation for spam&mdash;being the easy choice, a platform that you can set up yourself with no
gatekeeper (compare to Movable Type, professionally hosted WordPress installations, or Blogger
instances), it&rsquo;s become the choice for people who want to automatically deploy large numbers of
WordPress instances targeted to specific content/keyword niches. Then there&rsquo;s the architecture
matter: maybe this is just taste, but I find things like <code>rewind_posts()</code> inherently suspect (and
there are <a href="http://www.reddit.com/r/lolphp/comments/1etq3n/wordpress_will_automatically_convert_foo_to_foo/">unproven allegations</a> of grotesque features lurking in the codebase). More
substantially, there&rsquo;s mutable global state lurking all over the place (on top of the distressing
action-at-a-distance issues PHP inherently has&mdash;see Eevee&rsquo;s writeup for more about that), the app
buys into <a href="http://www.reddit.com/r/lolphp/comments/1dzvjk/wordpress_core_is_secure_stop_telling_people/c9vlcpi">the &ldquo;sanitize input&rdquo; voodoo</a>, and like most PHP apps, it requires a bunch of
read-and-write access to its environment that a better app wouldn&rsquo;t. This is part of the ongoing
security problem WordPress faces&mdash;which leads us to talking about PHP&rsquo;s role in software platforms
and ecosystems.</p>

<h3>The Superfund Site Of Programming Languages</h3>

<p>At this point we need to get abstract for a minute. Part of why infosec is important is that we do
not create, modify, or use software in isolation. We interact with software in a social context, in
a technological context, in a networked context. Similar to how herd immunity in medicine means
that the chance of catching a particular disease is unevenly distributed, software vulnerabilities
are dangerous even to people who aren&rsquo;t running the affected software. The most common thing that
an attacker might do with a compromised machine is suborn its resources, using it to propagate
further attacks (e.g. having it join a botnet). This is why it&rsquo;s particularly dismaying that PHP is
so big and so bad: even if I don&rsquo;t run anything based on PHP myself (or based on its
<a href="http://grimoire.ca/mysql/choose-something-else">co-conspirator in suckitude</a>, MySQL), PHP is still a problem for me.</p>

<p>The problem is severe, too. A security researcher finds that of sites vulnerable to password dumps,
<a href="http://blog.passwordresearch.com/2013/02/passwords-found-in-wild-for-january-2013.html">most are built on PHP</a>. A remote-code-execution vulnerability in two of the most
popular WordPress plugins is discovered&mdash;and the subsequent patches have an
<a href="http://hackertarget.com/running-wordpress-patch-your-plugins/">utterly dismal uptake rate</a>. There are a multitude of PHP-based server control
panels that have deeply <a href="http://seclists.org/fulldisclosure/2013/Apr/139">disturbing security problems</a> of
<a href="http://www.reddit.com/r/programming/comments/1gfve8/how_not_to_handle_a_critical_security/">grave severity</a>. A search on GitHub reveals a multitude of PHP projects open to a
<a href="https://github.com/search?p=1&amp;q=extension%3Aphp+mysql_query+%24_GET&amp;ref=searchresults&amp;type=Code">trivial SQL injection</a> attack. A bug in parsing URLs&mdash;surely an action that should
be a core competency for a &ldquo;web language&rdquo;!&mdash;turns out to be
<a href="https://www.idontplaydarts.com/2013/06/http-parameter-pollution-with-cookies-in-php/">implemented in the shoddiest way</a>.</p>

<p>The popularity of apps like WordPress exacerbates the security problems: WordPress has become a
<em>platform</em> as much as it is an app, and the difficult transition from app to platform, it has had
trouble with. When you run WordPress, the potential problems are determined not by the worst code
you wrote nor the worst code that the WP team wrote, but by the union of that code and
<a href="http://thedailywtf.com/Articles/Pot-o-Gold.aspx">the worst code</a> that the authors of any plugin or theme you use wrote. There are a
<em>huge</em> number of WordPress themes and plugins, and they can effectively run anything&mdash;my favorite
example is <a href="http://wordpress.org/plugins/repress/">RePress</a>, which staples a web proxy onto the side of your blog for the
use of folks in locales where services like Google and Wikipedia are blocked. WordPress is a
particularly problematic example because its target audience is non-engineering users. Someone who
sets up an instance of MediaWiki, Joomla, or Drupal faces a higher barrier to entry than a
WordPress user, who is the beneficiary of vigorous and successful efforts to make WordPress
accessible to a wide audience.</p>

<p>Unfortunately, that experience of easy-to-install software ends up recapitulating the experience of
the Windows 9x era: it&rsquo;s easy to install something that creates an opportunity for attackers, and
not easy to tell ahead of time which things you install belong in that category. In WordPress'
case, some of its most high-profile plugins, like the <a href="http://www.hyphenet.com/blog/2013/02/01/hackers-still-scanning-for-vulnerable-timthumb-scripts/">TimThumb image resizer</a> and the
caching plugins discussed earlier (and by the way it speaks very poorly of WordPress that two of
the most popular plugins are caching hacks attempting to work around WordPress' run-time
inefficiency), have seen remote-code-execution vulnerabilities that can be exploited at scale, by
botnets&mdash;and which are particularly likely to succeed against users of WordPress whose blogs and
their upkeep are not an every-waking-moment concern.</p>

<p>I worked with <a href="http://seclists.org/fulldisclosure/2009/Feb/255">Magento</a> professionally for a while, and one thing that gave me
massive creepy-crawlies about it was that it has the same problem as WordPress in the form of a
wild and problematic plugin ecosystem, but centered around an app that&rsquo;s meant to be handling
people&rsquo;s credit-card information. &ldquo;All the security of WordPress, but handles credit-card data!&rdquo;
does not inspire confidence. At least with eBay now running the show, there&rsquo;s a good chance that
Magento will have the budget to shape up security-wise.</p>

<p>If the problems I&rsquo;ve been talking about only affected the people actually running that software,
I&rsquo;d care far less. It&rsquo;s important that people have to some extent the right to make their own dang
mistakes. But these things don&rsquo;t happen in a vacuum. Every unpatched MediaWiki install sitting
around, every forgotten WordPress instance, every homebrew app quietly chugging away, is
susceptible to becoming part of a botnet and worsening the state of the entire Internet. Every
machine that gets rooted, is another machine conducting attacks of one kind or another&mdash;and even
if I run my own servers on the magical free-ponies language of sparkles and no security
vulnerabilities ever, a legion of zombie PHP-running boxes can still just throw denial-of-service
attacks my way until it doesn&rsquo;t matter what I&rsquo;m running.</p>

<p>This is why it matters that PHP is both big and bad: by being both ubiquitous and insecure, it
pollutes the commons. It adds unncessary cost and friction to any project we undertake that&rsquo;s
connected to the Internet&mdash;that is to say, nearly everything. Every server that connects to the
Internet has its attack surface artificially enlarged because PHP&rsquo;s own attack surface is so
vast. Programming doesn&rsquo;t happen in a vacuum, it happens in an ecosystem&mdash;an ecosystem that
PHP-based systems have a long and terrifying track record of dumping nuclear waste into.</p>
]]></content>
  </entry>
  
</feed>
